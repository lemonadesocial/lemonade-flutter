directive @expanded(
  from: String!
  to: String!
  resolve: Boolean
  return_type: String
  include_inactive: Boolean
) on FIELD_DEFINITION

directive @secure(paths: [String!]!) on FIELD_DEFINITION

type Query {
  getBadges(
    skip: Int! = 0
    limit: Int! = 25
    _id: [MongoID!]
    list: [MongoID!]
    city: String
    country: String

    """
    Distance in meters
    """
    distance: Float
  ): [Badge!]!
  getBadgeCities(skip: Int! = 0, limit: Int! = 25): [BadgeCity!]!
  getBadgeLists(
    skip: Int! = 0
    limit: Int! = 25
    user: MongoID
    title: String
  ): [BadgeList!]!
  getBroadcasts(provider: BroadcastProvider!): [Broadcast!]!
  getComments(
    input: GetCommentsArgs!
    skip: Int! = 0
    limit: Int! = 25
  ): [Comment!]!
  getConfigs(keys: [String!]!): JSON!
  getEventPendingInvites: GetEventPendingInvitesResponse!
  getEventCurrencies(_id: MongoID!, used: Boolean): [EventCurrency!]!
  getMyEvents(
    skip: Int! = 0
    limit: Int! = 25
    state: GetEventsState
    subevent_parent: MongoID
    tags: [String!]
    draft: Boolean
  ): [Event!]!
  getHostingEvents(
    skip: Int! = 0
    limit: Int! = 25
    site: MongoID
    user: MongoID
    state: FilterEventInput
    sort: JSON
    draft: Boolean
  ): [Event!]!
  getEvent(_id: MongoID, shortid: String): Event
  getEvents(
    skip: Int
    limit: Int
    _id: [MongoID!]
    site: MongoID
    search: String
    accepted: MongoID
    highlight: Boolean
    subevent_parent: MongoID
    space: MongoID
    tags: [String!]
      @deprecated(
        reason: "No longer supported and will be removed soon. Consider using `space_tags` instead."
      )
    space_tags: [MongoID!]
    unpublished: Boolean
    start_from: DateTimeISO
    start_to: DateTimeISO
    end_from: DateTimeISO
    end_to: DateTimeISO
    host_filter: HostFilter
    sort: EventSortInput
  ): [Event!]!
  getHomeEvents(
    skip: Int! = 0
    limit: Int! = 25
    search: String
    tense: EventTense
    longitude: Float
    latitude: Float
    search_range: Float
  ): [Event!]!
  getEventInvitedStatistics(
    search: String
    _id: MongoID!
  ): GetEventInvitedStatisticsResponse!
  getProfileEvents(skip: Int! = 0, limit: Int! = 25, user: MongoID): [Event!]!
  getPastEvents(
    skip: Int! = 0
    limit: Int! = 25
    site: MongoID
    user: MongoID
    space: MongoID
    sort: JSON
    hosting_only: Boolean
  ): [Event!]!
  getUpcomingEvents(
    skip: Int! = 0
    limit: Int! = 25
    search: String
    site: MongoID
    user: MongoID
    space: MongoID

    """
    Set to `true` to list only hosting events, `false` to exclude them. If not specified, all hosting, invited, and pending request events will be listed.
    """
    host: Boolean
    sort: JSON
  ): [Event!]!
  getEventTags(all: Boolean): [String!]!
  listEventHosts(
    skip: Int! = 0
    limit: Int! = 25
    name: String
  ): ListEventHostsResponse!
  getEventApplicationAnswers(
    event: MongoID!
    user: MongoID
    email: String
  ): [EventApplicationAnswer!]!
  getApplicantsInfo(
    users: [MongoID!]
    emails: [String!]
    event: MongoID!
  ): [Applicant!]!
  exportEventApplications(event: MongoID!): [EventApplicationExport!]!
  getEventCheckins(input: GetEventCheckinsInput!): [EventCheckin!]!
  getEventCohostInvites(
    input: GetEventCohostRequestsInput!
  ): [EventCohostRequest!]!
  getEventCohostRequests(
    input: GetEventCohostRequestsInput!
  ): [EventCohostRequest!]!
  getEventAttestation(chain_id: String!, event: MongoID!): EventAttestation
  getEventAttestationDiff(
    chain_id: String!
    event: MongoID!
  ): EventAttestationDiff
  getEventEmailSetting(_id: MongoID!): EmailSetting!
  listEventEmailSettings(
    event: MongoID!
    system: Boolean
    scheduled: Boolean
    sent: Boolean
  ): [EmailSetting!]!
  getEventFeedbackSummary(event: MongoID!): EventFeedbackSummary!
  listEventFeedBacks(
    skip: Int! = 0
    limit: Int! = 25
    event: MongoID!
    rate_value: Float
  ): [EventFeedback!]!

  """
  For guests, return attending guests basic information of an event
  """
  getEventGuestDirectory(_id: MongoID!): [BasicUserInfo!]!
  getEventGuestDetail(
    event: MongoID!
    user: MongoID
    email: String
  ): EventGuestDetail
  getEventInvitation(event: MongoID!): EventInvitation
  generateEventInvitationUrl(
    event: MongoID!
  ): GenerateEventInvitationUrlResponse
  getEventInvitationUrl(shortid: String!, tk: String): EventInvitationUrl
  getEventJoinRequests(
    skip: Int! = 0
    limit: Int! = 25
    event: MongoID!
    state: EventJoinRequestState
    search: String
    payment_expired: Boolean
  ): GetEventJoinRequestsResponse!
  getMyEventJoinRequest(event: MongoID!): EventJoinRequest
  getEventJoinRequest(event: MongoID!, _id: MongoID!): EventJoinRequest!
  getEventPaymentSummary(event: MongoID!): [EventPaymentSummary!]!
  getEventQuestions(input: GetEventQuestionsInput!): [EventQuestion!]!
  generateRecurringDates(input: GenerateRecurringDatesInput!): [DateTimeISO!]!
  getEventRewardUses(input: GetEventRewardUsesInput!): [EventRewardUse!]!
  getEventSessionReservations(
    input: GetEventSessionReservationsInput
  ): [EventSessionReservation!]!
  getEventSessionReservationSummary(
    input: GetEventSessionReservationSummaryInput!
  ): [EventSessionReservationSummary!]!
  getEventTicketCategories(event: MongoID!): [EventTicketCategory!]!
  getEventTicketSales(event: MongoID!): EventTicketSaleResponse!
  listEventTicketTypes(event: MongoID!): [EventTicketType!]!
  getEventTicketTypes(
    input: GetEventTicketTypesInput!
  ): GetEventTicketTypesResponse!
  getEventbriteEvents(
    input: GetEventbriteEventsInput
    skip: Int! = 0
    limit: Int! = 25
  ): [EventbriteEvent!]!
  getFiles(
    skip: Int! = 0
    limit: Int! = 25
    id_lt: MongoID
    user: MongoID
    links: FileLinkInput
  ): [File!]!
  getFrequentQuestions(input: GetFrequentQuestionsInput!): [FrequentQuestion!]!
  getGuildRooms: [GuildRoom!]!
  getMyPayments(state: FilterPaymentStateInput, event: MongoID): [NewPayment!]!
  getNewPayment(payment_secret: String, _id: MongoID!): NewPayment
  listNewPayments(
    skip: Int! = 0
    limit: Int! = 25
    event: MongoID!
    ids: [MongoID!]
    users: [MongoID!]
  ): [NewPayment!]!
  getPaymentRefundSignature(_id: MongoID!): PaymentRefundSignature!
  listFiatCurrencies: [FiatCurrency!]!
  listAllCurrencies: [Currency!]!
  listChains: [Chain!]!
  listNewPaymentAccounts(
    skip: Int! = 0
    limit: Int! = 25
    _id: [MongoID!]
    type: PaymentAccountType
    provider: NewPaymentProvider
  ): [NewPaymentAccount!]!
  getPosts(input: GetPostsInput, skip: Int! = 0, limit: Int! = 25): [Post!]!
  getNewsfeed(offset: Float): Newsfeed
  getNotifications(
    skip: Int! = 0
    limit: Int! = 25
    type: NotificationTypeFilterInput
  ): [Notification!]!
  listOauth2Clients(ids: [String!]): [OAuth2Client!]!
  getOffers(type: OfferType!): [Offer!]!
  getPointGroups(with_count: Boolean): [PointGroup!]!
  getMyPoints(
    first_level_group: MongoID
    second_level_group: MongoID
  ): [PointConfigInfo!]!
  getRooms(input: GetRoomsInput!): [Room!]!
  getRoom(_id: MongoID!): Room
  getRoomCredentials(input: GetRoomCredentialsInput!): RoomCredentials!
  getSafeFreeLimit(network: String!): FreeSafeInitInfo!
  getInitSafeTransaction(input: GetInitSafeTransactionInput!): RawTransaction!
  getSites(
    skip: Int! = 0
    limit: Int! = 25
    _id: [MongoID!]
    active: Boolean
  ): [Site!]!
  listSpaces(
    with_my_spaces: Boolean
    with_public_spaces: Boolean
    roles: [SpaceRole!]
  ): [Space!]!
  getSpace(hostname: String, slug: String, _id: MongoID): Space
  canUseSpaceSlug(slug: String!): Boolean!
  listSpaceMembers(
    skip: Int
    limit: Int
    space: MongoID!
    role: SpaceRole
      @deprecated(
        reason: "Use `roles` instead. Avoid using both `role` and `roles` simultaneously to prevent potential bugs."
      )
    roles: [SpaceRole!]
    state: SpaceMembershipState
    visible: Boolean
    search: String

    """
    - true: Lists deleted space members.
    - false: Lists all space members that are not deleted.
    - Not specified: Lists all space members.
    """
    deletion: Boolean
    tags: [MongoID!]
    sort: SortInput
  ): ListSpaceMembersResponse!
  getSpaceMember(user: MongoID, _id: MongoID, space: MongoID!): SpaceMember!
  listSpaceRoleFeatures(
    space: MongoID!
    role: SpaceRole!
  ): ListSpaceRoleFeaturesResponse!
  getStore(promotion: MongoID, _id: MongoID): Store
  getStores(
    skip: Int! = 0
    limit: Int! = 25
    user: MongoID
    longitude: Float
    latitude: Float
    country: String
    region: String
    city: String
    postal: String
    tags: String
  ): [Store!]!
  getStoreDeliveryOptions(
    store: MongoID!
    address: AddressInput!
  ): [DeliveryOption!]!
  getStoreSalesTax(store: MongoID!, address: AddressInput!): SalesTax!
  getStoreBucketItems(skip: Int! = 0, limit: Int! = 25): [StoreBucketItem!]!
  getStoreCategory(_id: MongoID!): StoreCategory
  getStoreCategories(
    skip: Int! = 0
    limit: Int! = 25
    store: MongoID
    parents: MongoID
  ): [StoreCategory!]!
  getStoreOrder(_id: MongoID!): StoreOrder
  getStoreOrders(
    skip: Int! = 0
    limit: Int! = 25
    store: MongoID
    place_reservation: MongoID
    state: StoreOrderStateFilterInput
  ): [StoreOrder!]!
  getStoreProduct(_id: MongoID!): StoreProduct!
  getStoreProducts(
    skip: Int! = 0
    limit: Int! = 25
    store: MongoID
    categories: MongoID
  ): [StoreProduct!]!
  getStripeTransferDetail(_id: MongoID!): JSON!
  getStripeCards(skip: Int! = 0, limit: Int! = 25): [StripeCard!]!
  getStripeConnectedAccountCapability: StripeAccountCapability
  tgGetMyChannels(input: ScanChannelsInput!): ScanChannelsResult!
  joinChannel(event_ids: MongoID!): Boolean!
  calculateTicketsPricing(input: CalculateTicketsPricingInput!): PricingInfo!
  getTickets(
    skip: Int! = 0
    limit: Int! = 25
    _id: [MongoID!]
    event: MongoID
    user: MongoID
    email: String
    payment: MongoID

    """
    Get tickets of the specified ticket types
    """
    ticket_types: [MongoID!]
  ): [Ticket!]!
  getTicket(shortid: String!): Ticket
  getMyTickets(
    event: MongoID!
    with_payment_info: Boolean
  ): GetMyTicketsResponse!
  getTicketStatistics(id: MongoID!): TicketStatistics!
  exportEventTickets(
    _id: MongoID!
    ticket_type_ids: [MongoID!]
    search_text: String
    checked_in: Boolean
    pagination: PaginationInput
  ): ExportedTickets!
  getRecommendedUsers(skip: Int! = 0, limit: Int! = 25): [User!]!
  getMe: User!
  getUser(
    _id: MongoID
    username: String
    email: String
    matrix_localpart: String
  ): User
  getUsers(
    skip: Int! = 0
    limit: Int! = 25
    _id: [MongoID!]
    tag_recommended: Boolean
    wallets: [String!]
    search: String
  ): [User!]!
  getUsersSpotlight: [User!]!
  getUserContacts(
    skip: Int! = 0
    limit: Int! = 25
    input: GetUserContactsInput
  ): GetUserContactsResponse!
  getUserDiscovery(
    longitude: Float!
    latitude: Float!
    search_range: Float
    event: MongoID
    offerings: [MongoID!]
  ): UserDiscovery!
  getUserDiscoverySwipes(
    skip: Int! = 0
    limit: Int! = 25
    incoming: Boolean
    state: UserDiscoverySwipeState
    other_wallets: Boolean
  ): [UserDiscoverySwipe!]!
  getUserFollows(
    skip: Int! = 0
    limit: Int! = 25
    input: GetUserFollowsInput!
  ): [UserFollow!]!
  getUserFriendships(
    skip: Int! = 0
    limit: Int! = 25
    input: GetUserFriendshipsInput
  ): GetUserFriendshipsResponse!
  getUserIcebreakerQuestions: [UserIcebreakerQuestion!]!
  getUserFromUserMigration(username: String, email: String): NonloginUser
  getUserPaymentVerification: UserPaymentVerificationInfo!
  listUserServices: [UserServiceOffer!]!
  listUserExpertises: [UserExpertise!]!
  getUserWalletRequest(wallet: String!): UserWalletRequest!
  listEventVotings(
    event: MongoID!
    votings: [MongoID!]
    hidden: Boolean
  ): [EventVoting!]!
  listEventStakePayments(
    skip: Int
    limit: Int
    search: String
    event: MongoID!
    networks: [String!]
  ): ListEventStakePaymentsResponse!
  generateSlashPaymentSignature(
    event: MongoID!
    paymentIds: [MongoID!]!
  ): PaymentRefundSignature!
  getStakePaymentStatistics(event: MongoID!): StakePaymentStatistics!
  getVaultSalt(name: String!, type: String!): String!
  getMySpaceEventRequests(
    skip: Int! = 0
    limit: Int! = 25
    space: MongoID!
    state: EventJoinRequestState
  ): GetSpaceEventRequestsResponse!
  getSpaceEventRequests(
    skip: Int! = 0
    limit: Int! = 25
    space: MongoID!
    state: EventJoinRequestState
  ): GetSpaceEventRequestsResponse!
  listSpaceTags(space: MongoID!): [SpaceTagBase!]!
  listRewardVaults: [TokenRewardVault!]!
  listCheckinTokenRewardSettings(
    ticket_types: [MongoID!]
    event: MongoID!
  ): [CheckinTokenRewardSetting!]!
  listTicketTokenRewardSettings(
    ticket_types: [MongoID!]
    event: MongoID!
  ): [TicketTokenRewardSetting!]!
  generateClaimCheckinRewardSignature(
    event: MongoID!
  ): ClaimCheckinRewardSignatureResponse
  generateClaimTicketRewardSignature(
    payment: MongoID
    event: MongoID!
  ): ClaimTicketRewardSignatureResponse
  getEventPaymentStatistics(event: MongoID!): EventPaymentStatistics!
  getEventPayment(event: MongoID!, _id: MongoID!): NewPayment
  listEventPayments(
    skip: Int
    limit: Int
    event: MongoID!
    provider: NewPaymentProvider
    networks: [String!]
    ticket_types: [MongoID!]
    checked_in: Boolean
    search: String
  ): ListEventPaymentsResponse!
  listDonationVaults: [DonationVault!]!
  listDonationRecommendations: [DonationRecommendation!]!
  listDonations(
    skip: Int
    limit: Int
    event: MongoID!
    vaults: [MongoID!]
    networks: [String!]
    from_users: [MongoID!]
    from_emails: [String!]
    search: String
    sort: SortOrder
  ): ListDonationsResponse!
  listSpaceTokenGates(space: MongoID!): [SpaceTokenGate!]!
}

type Badge {
  _id: MongoID!
  list: MongoID!
  network: String!
  contract: String!
  city: String
  country: String

  """
  Distance in meters
  """
  distance: Float
  claimable: Boolean
  list_expanded: BadgeList
}

scalar MongoID

type BadgeList {
  _id: MongoID!
  title: String!
  image_url: String
  user: MongoID!
  user_expanded: User
}

type User {
  _id: MongoID
  active: Boolean!
  created_at: DateTimeISO!
  updated_at: DateTimeISO!
  name: String!
  verified: Boolean
  phone: String
  phone_verified: Boolean
  email: String
  email_marketing: Boolean
  email_verified: Boolean
  country: String
  display_name: String
  first_name: String
  last_name: String
  type: UserType
  search_range: Float
  lemon_amount: Float!
  lemon_cap: Float!
  discovery: UserDiscoverySettings
  addresses: [Address!]
  age: Float
  blocked: [MongoID!]
  calendly_url: String
  currency: String
  company_address: Address
  company_name: String
  cover: MongoID
  date_of_birth: DateTimeISO
  description: String
  education_title: String
  ethnicity: String
  events: [MongoID!]
  expertise: [MongoID!]
  frequent_questions: [FrequentQuestion!]
  handle_facebook: String
  handle_farcaster: String
  handle_github: String
  handle_instagram: String
  handle_lens: String
  handle_linkedin: String
  handle_mirror: String
  handle_twitter: String
  image_avatar: String
  industry: String
  interests: [String!]
  job_title: String
  languages: [String!]
  layout_sections: [LayoutSection!]
  location_line: String
  music: [String!]
  offers: [UserOffer!]
  preferred_network: String
  pronoun: String
  new_gender: String
  new_photos: [MongoID!]
  service_offers: [MongoID!]
  tag_recommended: Boolean
  tag_site: Boolean
  tag_timeline: Boolean
  tag_verified: Boolean
  tagline: String
  timezone: String
  username: String
  settings: JSON
  wallets: [String!]
  wallets_new: JSON
  wallet_custodial: String
  attended: Float
  followers: Float
  following: Float
  friends: Float
  hosted: Float
  posts: Float
  discord_user_info: JSON
  farcaster_user_info: FarcasterUserInfo
  lemon_refresh_at: DateTimeISO
  fcm_tokens: [String!]
  matrix_localpart: String
  payment_verification: UserPaymentVerification
  url: String
  url_go: String
  daos: [UserDao!]
  data: JSON
  eventbrite_user_info: JSON
  google_user_info: JSON
  stripe_user_info: JSON
  terms_accepted_adult: Boolean
  terms_accepted_conditions: Boolean
  notification_filters: [JSON!]
  razorpay_customer: String
  shopify_user_info: JSON
  twitch_user_info: JSON
  twitter_user_info: JSON
  twitter2_user_info: JSON
  zoom_user_info: JSON
  telegram_user_info: JSON
  stripe_connected_account: StripeConnectedAccount
  farcaster_fid: Float
  quest_points: Float
  icebreakers: [UserIcebreaker!]
  service_offers_expanded: [UserServiceOffer]
  expertise_expanded: [UserExpertise]
  cover_expanded: File
  events_expanded(skip: Int! = 0, limit: Int! = 25): [Event]
  new_photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  blocked_expanded: [User]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

enum UserType {
  Admin
}

type UserDiscoverySettings {
  enabled: Boolean!
  min_age: Float!
  max_age: Float!
}

type Address {
  _id: MongoID
  recipient_name: String
  street_1: String
  street_2: String
  city: String
  region: String
  postal: String
  country: String
  title: String
  phone: String
  longitude: Float
  latitude: Float
  additional_directions: String
}

type FrequentQuestion {
  _id: MongoID
  type: [FrequentQuestionType!]!
  question: String!
  answer: String!
  position: Float
  tag: String
}

enum FrequentQuestionType {
  event
  poap
  user
}

type LayoutSection {
  id: String
  hidden: Boolean
}

type UserOffer {
  _id: MongoID
  provider: OfferProvider!
  provider_network: String!
  provider_id: String!
  position: Float
  auto: Boolean
}

enum OfferProvider {
  claimable
  festival_heads
  metaverse
  order
  poap
  token
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type FarcasterUserInfo {
  fid: Float
  account_key_request: AccountKeyRequest
}

type AccountKeyRequest {
  accepted: Boolean
  token: String!
  deeplink_url: String!
}

type UserPaymentVerification {
  stamp: DateTimeISO!
  state: UserPaymentVerificationState!
  reason: String
  verified_by: MongoID
}

enum UserPaymentVerificationState {
  pending
  declined
  completed
}

type UserDao {
  network: String!
  address: String!
}

type StripeConnectedAccount {
  account_id: String!
  connected: Boolean
}

type UserIcebreaker {
  _id: MongoID
  question: MongoID!
  value: String!
  question_expanded: UserIcebreakerQuestion
}

type UserIcebreakerQuestion {
  _id: MongoID!
  title: String!
  description: String
}

type UserServiceOffer {
  _id: MongoID!
  title: String!
}

type UserExpertise {
  _id: MongoID!
  title: String!
}

type File {
  _id: MongoID
  stamp: DateTimeISO!
  state: FileState!
  owner: MongoID!
  type: String!
  size: Float
  url: String!
  bucket: String!
  key: String!
  links: [FileLink!]
  likes: Float!
  likers: [MongoID!]
  description: String
  owner_expanded: User
  liked: Boolean
  link_events_expanded(skip: Int! = 0, limit: Int! = 25): [Event]
  link_stores_expanded(skip: Int! = 0, limit: Int! = 25): [Store]
  link_store_products_expanded(skip: Int! = 0, limit: Int! = 25): [StoreProduct]
  link_users_expanded(skip: Int! = 0, limit: Int! = 25): [User]
}

enum FileState {
  done
  error
  started
}

type FileLink {
  model: String!
  id: MongoID!
  path: String!
  type: FileLinkType!
}

enum FileLinkType {
  file_inline
  object_id
}

type Event {
  _id: MongoID
  shortid: String!
  active: Boolean!
  stamp: DateTimeISO!
  state: EventState!
  title: String!
  slug: String!
  start: DateTimeISO!
  end: DateTimeISO!
  host: MongoID!
  cohosts: [MongoID!]
  visible_cohosts: [MongoID!]
  invited: [MongoID!]
  inviters: [MongoID!]
  pending: [MongoID!]
  accepted: [MongoID!]
  declined: [MongoID!]
  payment_fee: Float!
  donation_enabled: Boolean
  donation_show_history: Boolean
  donation_vaults: [MongoID!]
  application_required: Boolean
  rsvp_wallet_platforms: [ApplicationBlokchainPlatform!]
  application_form_url: String
  application_profile_fields: [ApplicationProfileField!]
  accepted_store_promotion: MongoID
  accepted_user_fields_required: [String!]
  access_pass: AccessPass
  address: Address
  address_directions: [String!]
  approved: Boolean
  broadcast_rooms: [BroadcastRoom!]
  button_icon: String
  button_text: String
  button_url: String
  comments: String
  cost: Float
  currency: String
  cover: String
  cta_button_text: String

  """
  Show secondary CTA button text
  """
  cta_secondary_visible: Boolean
  description: String
  description_plain_text: String
  events: [MongoID!]
  frequent_questions: [FrequentQuestion!]
  guest_limit: Float
  guest_limit_per: Float
  guests: Int
  hide_chat_action: Boolean
  hide_cohosts: Boolean
  hide_creators: Boolean
  hide_lounge: Boolean
  hide_invite_action: Boolean
  hide_question_box: Boolean
  hide_rooms_action: Boolean
  hide_session_guests: Boolean
  hide_speakers: Boolean
  hide_stories_action: Boolean
  hide_attending: Boolean
  highlight: Boolean
  latitude: Float
  layout_sections: [LayoutSection!]
  location: Point
  longitude: Float
  new_photos: [FileInline!]
  new_new_photos: [MongoID!]
  offers: [EventOffer!]
  payment_accounts_new: [MongoID!]
  payment_donation: Boolean
  payment_donation_amount_includes_tickets: Boolean
  payment_donation_amount_increment: Float
  payment_donation_message: String
  payment_donation_target: Float
  payment_enabled: Boolean
  payment_optional: Boolean
  payment_ticket_external_message: String
  payment_ticket_external_url: String
  payment_ticket_purchase_title: String
  photos: [String!]
  private: Boolean
  published: Boolean
  registration_disabled: Boolean
  approval_required: Boolean
  rewards: [EventReward!]
  reward_uses: JSON
  session_guests: JSON
  speaker_users: [MongoID!]
  stores: [MongoID!]
  stories: [MongoID!]
  stories_eponym: Boolean
  space: MongoID
  listing_spaces: [MongoID!]
  tags: [String!]
  terms_email_permission_text: Boolean
  terms_text: String
  timezone: String
  unlisted: Boolean
  videos: [Video!]
  virtual: Boolean
  virtual_url: String
  welcome_text: String
  welcome_video: Video
  zones_menu_text: String
  checkin_menu_text: String

  """
  Number of users who have tickets
  """
  attending_count: Float
  checkin_count: Float
  payment_ticket_count: Float
  payment_ticket_unassigned_count: Float
  guest_directory_enabled: Boolean
  eventbrite_enabled: Boolean
  eventbrite_event_id: String
  eventbrite_tickets_imported: Boolean
  invited_count: Float
  inviter_user_map: JSON
  matrix_event_room_id: String
  inherited_cohosts: [MongoID!]
  subevent_enabled: Boolean
  subevent_settings: SubeventSettings
  subevent_parent: MongoID
  url: String
  url_go: String
  telegram_channels: [TelegramChannel!]
  donation_vaults_expanded: [DonationVault!]
  broadcasts: [Broadcast!]
  space_tags: [SpaceTagBase!]
  event_ticket_types: [EventTicketType!]
  pending_request_count: Float
  sessions: [EventSession!]
  has_terms_accepted: Boolean
  checkedin: Boolean
  ticket_count: Float
  data: JSON
  space_expanded: Space
  host_expanded: User
  subevent_parent_expanded: Event
  cohosts_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  visible_cohosts_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  invited_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  pending_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  accepted_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  declined_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  stores_expanded(skip: Int! = 0, limit: Int! = 25): [Store]
  new_new_photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  events_expanded(skip: Int! = 0, limit: Int! = 25): [Event]
  speaker_users_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  payment_accounts_expanded(
    skip: Int! = 0
    limit: Int! = 25
  ): [NewPaymentAccount]
  payment_ticket_discounts: [EventPaymentTicketDiscount!]
  tickets: [TicketBase!]
  application_questions: [EventApplicationQuestion!]
  application_form_submission: DateTimeISO
  calendar_links: EventCalendarLinks
  me_awaiting_approval: Boolean
}

enum EventState {
  created
  started
  ended
  cancelled
}

type ApplicationBlokchainPlatform {
  platform: BlockchainPlatform!
  required: Boolean
}

enum BlockchainPlatform {
  ethereum
  solana
}

type ApplicationProfileField {
  field: String!
  required: Boolean
}

type AccessPass {
  contract: String!
  network: String!
  frame: String!
  base: String!
  name: String!
  logo_url: String!
  info_url: String!
  card_image_url: String!
  card_logo_url: String!
  gallery_logo_url: String!
  card_description: String!
  dialog_background_url: String!
  dialog_title: String!
  dialog_description: String!
  metadata_name: String!
  metadata_description: String!
  metadata_creators: [String!]!
  unlocked_description: String
  twitter_url: String
  instagram_url: String
  discord_url: String
  checkin: Boolean
}

type BroadcastRoom {
  _id: MongoID
  title: String
  description: String
  photos: [MongoID!]
  event_payment_ticket_types: [MongoID!]
  position: Float
  iframe_src: String
  photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
}

type Point {
  type: String!
  coordinates: [Float!]!
}

type FileInline {
  id: MongoID!
  url: String!
  key: String!
  fa_file: MongoID
  fa_index: Float
}

type EventOffer {
  _id: MongoID
  provider: OfferProvider!
  provider_network: String!
  provider_id: String!
  position: Float
  auto: Boolean
  broadcast_rooms: [MongoID!]
}

type EventReward {
  _id: MongoID
  active: Boolean!
  title: String!
  limit: Float
  limit_per: Float!
  icon_color: String
  icon_url: String
  payment_ticket_types: [MongoID!]
}

type Video {
  provider: String!
  provider_id: String!
  title: String
  thumbnail: String
}

type SubeventSettings {
  ticket_required_for_creation: Boolean
  ticket_required_for_purchase: Boolean
}

type TelegramChannel {
  id: String
  accessHash: String
  photo: MongoID
  title: String
  username: String
  inviteLink: String
  joined: [MongoID!]
}

type DonationVault {
  _id: MongoID!
  title: String!
  user: MongoID!
  network: String!
  address: String!
  events: [MongoID!]
}

type Broadcast {
  _id: MongoID
  active: Boolean!
  user: MongoID!
  provider: BroadcastProvider!
  provider_id: String!
  title: String!
  life_cycle_status: BroadcastLifeCycleStatus!
  recording_status: BroadcastRecordingStatus!
  description: String
  position: Float
  rooms: [MongoID!]
  thumbnail: String
  scheduled_start_time: DateTimeISO
  start_time: DateTimeISO
  scheduled_end_time: DateTimeISO
  end_time: DateTimeISO
  meta_data: BroadcastMetaData
  processed_by_job: Boolean
  deactivation_code: String
  deactivation_message: String
  eligible: Boolean!
  user_expanded: User
}

enum BroadcastProvider {
  embed
  local
  twitch
  video
  youtube
  zoom
}

enum BroadcastLifeCycleStatus {
  complete
  created
  live
  liveStarting
  ready
  revoked
  testStarting
  testing
}

enum BroadcastRecordingStatus {
  notRecording
  recorded
  recording
}

type BroadcastMetaData {
  user: String
  title: String
  video: String
  password: String
  boundStreamId: String
  boundStreamStamp: DateTimeISO
  enableAutoStop: Boolean
  static_thumbnail: String
}

type SpaceTagBase {
  _id: MongoID!
  space: MongoID!
  tag: String!
  color: String!
  type: SpaceTagType!
  targets: [String!]
}

enum SpaceTagType {
  event
  member
}

type EventTicketType {
  _id: MongoID!
  active: Boolean
  private: Boolean
  limited: Boolean
  event: MongoID!
  title: String!
  category: MongoID
  default: Boolean
  address_required: Boolean
  description: String
  description_line: String
  external_ids: [String!]
  offers: [EventOffer!]
  photos: [MongoID!]
  ticket_count: Float
  ticket_limit: Float
  ticket_limit_per: Float
  position: Int
  approval_required: Boolean
  photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  limited_whitelist_users: [WhitelistUserInfo!]
  category_expanded: EventTicketCategory
  prices: [EventTicketPrice!]!
}

type WhitelistUserInfo {
  _id: MongoID
  email: String!
}

type EventTicketCategory {
  _id: MongoID!
  title: String!
  event: MongoID!
  description: String
  position: Int
}

type EventTicketPrice {
  default: Boolean
  currency: String!
  cost: String!
  payment_accounts: [MongoID!]
  payment_accounts_expanded: [NewPaymentAccount!]
}

type NewPaymentAccount {
  _id: MongoID!
  active: Boolean!
  created_at: DateTimeISO!
  user: MongoID!
  type: PaymentAccountType!
  title: String
  provider: NewPaymentProvider
  account_info: AccountInfo!
}

enum PaymentAccountType {
  solana
  ethereum
  ethereum_escrow
  ethereum_relay
  ethereum_stake
  digital
}

enum NewPaymentProvider {
  stripe
  safe
}

union AccountInfo =
    SolanaAccount
  | EthereumAccount
  | SafeAccount
  | DigitalAccount
  | StripeAccount
  | EthereumEscrowAccount
  | EthereumRelayAccount
  | EthereumStakeAccount

type SolanaAccount {
  currencies: [String!]!
  currency_map: JSON
  address: String!
  network: String!
}

type EthereumAccount {
  currencies: [String!]!
  currency_map: JSON
  address: String!
  network: String!
}

type SafeAccount {
  currencies: [String!]!
  currency_map: JSON
  address: String!
  network: String!
  owners: [String!]!
  threshold: Float!
  pending: Boolean
}

type DigitalAccount {
  currencies: [String!]!
  currency_map: JSON
  account_id: String!
}

type StripeAccount {
  currencies: [String!]!
  currency_map: JSON
  account_id: String!
  publishable_key: String!
}

type EthereumEscrowAccount {
  currencies: [String!]!
  currency_map: JSON
  address: String!
  network: String!
  minimum_deposit_percent: Int!
  host_refund_percent: Float!
  refund_policies: [RefundPolicy!]
}

type RefundPolicy {
  timestamp: Float!
  percent: Float!
}

type EthereumRelayAccount {
  currencies: [String!]!
  currency_map: JSON
  address: String!
  network: String!
  payment_splitter_contract: String
}

type EthereumStakeAccount {
  currencies: [String!]!
  currency_map: JSON
  address: String!
  network: String!
  config_id: String!
  requirement_checkin_before: DateTimeISO
}

type EventSession {
  _id: MongoID
  title: String!
  start: DateTimeISO!
  end: DateTimeISO!
  broadcast: MongoID
  description: String
  photos: [MongoID!]
  speaker_users: [MongoID!]
  votings: [MongoID!]
  photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  speaker_users_expanded(skip: Int! = 0, limit: Int! = 25): [User]
}

type Space {
  _id: MongoID!
  title: String!
  description: String
  creator: MongoID!

  """
  Private space requires moderation for membership
  """
  private: Boolean
  state: SpaceState!
  personal: Boolean
  followers: [MongoID!]
  daos: SpaceDao
  tint_color: String
  slug: String
  handle_twitter: String
  handle_instagram: String
  handle_youtube: String
  handle_tiktok: String
  handle_linkedin: String
  website: String
  address: Address
  image_avatar: MongoID
  image_cover: MongoID

  """
  External events are listed on this space
  """
  listed_events: [MongoID!]
  theme_data: JSON
  hostnames: [String!]
  followed: Boolean
  is_ambassador: Boolean
  admins: [User!]
  creator_expanded: User
  image_avatar_expanded: File
  image_cover_expanded: File
}

enum SpaceState {
  active
  archived
}

type SpaceDao {
  network: String!
  address: String!
  name: String!
}

type Store {
  _id: MongoID!
  active: Boolean!
  stamp: DateTimeISO!
  user: MongoID!
  managers: [MongoID!]!
  title: String!
  payment_fee_store: Float!
  payment_fee_user: Float!
  currency: String!
  fulfillment_addresses: [Address!]!
  address: Address
  api_secret: String
  easyship_enabled: Boolean
  easyship_company_id: String
  easyship_token: String
  easyship_secret_key: String
  approved: Boolean
  pickup_addresses: [Address!]
  delivery_options: [DeliveryOption!]
  sales_taxes: [SalesTax!]
  photos: [FileInline!]
  new_photos: [MongoID!]!
  order_count: Float
  tags: [String!]
  age_restriction_min: Float
  age_restriction_reason: String
  managers_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  user_expanded: User
  new_photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  promotions: [StorePromotion]
}

type DeliveryOption {
  _id: MongoID!
  type: DeliveryOptionType!
  title: String!
  cost: Float!
  fulfillment_address: MongoID
  pickup_addresses: [MongoID!]
  waive_type: DeliveryOptionWaiveType
  waive_value_threshold: Float
  group: String
  description: String
  longitude: Float
  latitude: Float
  search_range: Float
  polygon: JSON
  countries: [String!]
  regions: [String!]
  cities: [String!]
  postals: [String!]
  postal_ranges: [DeliveryOptionPostalRange!]
}

enum DeliveryOptionType {
  worldwide
  country
  region
  city
  postal
  geo_zone
}

enum DeliveryOptionWaiveType {
  store
  product
  any
}

type DeliveryOptionPostalRange {
  _id: MongoID!
  pattern: String!
  min: Float!
  max: Float!
}

type SalesTax {
  _id: MongoID!
  type: SalesTaxType!
  name: String
  flat_map: JSON
  ratio_map: JSON
  countries: [String!]
  regions: [String!]
}

enum SalesTaxType {
  worldwide
  country
  region
}

type StorePromotion {
  _id: MongoID!
  active: Boolean!
  type: StorePromotionType!
  title: String!
  ratio: Float!
  use_count: Float
  use_count_map: JSON
  use_limit: Float
  use_limit_per: Float
  waive_delivery_option_cost: Boolean
  event: MongoID
  products: [MongoID!]
  products_expanded(skip: Int! = 0, limit: Int! = 25): [StoreProduct]
}

enum StorePromotionType {
  event
}

type StoreProduct {
  _id: MongoID!
  active: Boolean!
  stamp: DateTimeISO!
  store: MongoID!
  order: Float!
  title: String!
  description: String!
  categories: [MongoID!]
  delivery_options: [DeliveryOption!]
  easyship_category: EasyshipCategory
  sales_tax_tag: String
  groups: JSON
  highlight: Boolean
  primary_group: String
  variants: [StoreProductVariant!]!
  store_expanded: Store
}

enum EasyshipCategory {
  mobiles
  tablets
  computers_laptops
  cameras
  accessory_no_battery
  accessory_battery
  health_beauty
  fashion
  watches
  home_appliances
  home_decor
  toys
  sport
  luggage
  audio_video
  documents
  jewelry
  dry_food_supplements
  books_collectionables
  pet_accessory
  gaming
}

type StoreProductVariant {
  _id: MongoID!
  title: String!
  cost: Float!
  groups: JSON!
  weight: Float!
  length: Float!
  width: Float!
  height: Float!
  photos: [FileInline!]
  new_photos: [MongoID!]
  inventory: Float
  new_photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
}

type EventPaymentTicketDiscount {
  active: Boolean!
  stamp: DateTimeISO!
  code: String!
  ratio: Float!
  use_count: Float
  use_count_map: JSON
  users: [MongoID!]
  ticket_count: Float
  ticket_count_map: JSON
  use_limit: Float
  use_limit_per: Float
  ticket_limit: Float
  ticket_limit_per: Float
  ticket_types: [MongoID!]
  users_expanded(skip: Int! = 0, limit: Int! = 25): [User]
}

type TicketBase {
  _id: MongoID!
  shortid: String!
  created_at: DateTimeISO!
  event: MongoID!
  type: MongoID!
  accepted: Boolean
  acquired_by: MongoID
  cancelled_by: MongoID
  acquired_by_email: String
  assigned_email: String
  assigned_to: MongoID
  invited_by: MongoID
  payment_id: MongoID
  metadata: JSON
  assigned_to_info: ConfidentialUserInfo
}

type ConfidentialUserInfo {
  _id: MongoID
  name: String!
  display_name: String
  image_avatar: String
  username: String
  email: String
}

type EventApplicationQuestion {
  _id: MongoID!
  question: String
  required: Boolean
  position: Int
  type: QuestionType
  options: [String!]
  select_type: SelectType
  questions: [String!] @deprecated(reason: "Nolonger needed")
}

"""
The type of the question in the event application question
"""
enum QuestionType {
  text
  options
  checkbox
  website
  company
}

"""
Select type for the question of type "options"
"""
enum SelectType {
  single
  multi
}

type EventCalendarLinks {
  google: String!
  yahoo: String!
  outlook: String!
  ical: String!
}

type BadgeCity {
  city: String!
  country: String!
}

type Comment {
  _id: MongoID!
  created_at: DateTimeISO!
  text: String!
  post: MongoID!
  user: MongoID!
  comment: MongoID
  user_expanded: User
}

input GetCommentsArgs {
  post: MongoID!
  comment: MongoID
}

type GetEventPendingInvitesResponse {
  event_invites: [EventInvite!]
  cohost_requests: [EventInvite!]
}

type EventInvite {
  event: MongoID!
  inviter: MongoID!
  event_expanded: Event
  inviter_expanded: User
}

type EventCurrency {
  currency: String!
  decimals: Float!
  network: String
}

enum GetEventsState {
  ACCEPTED
  DECLINED
  INVITED
  PENDING
}

input FilterEventInput {
  eq: EventState
  in: [EventState!]
  nin: [EventState!]
}

input HostFilter {
  host: MongoID
    @deprecated(
      reason: "Use \"hosts\" instead. This field will be removed soon."
    )
  hosts: [MongoID!]
  include_owned_events: Boolean
  include_cohost_events: Boolean
  include_subevents: Boolean
}

input EventSortInput {
  start: SortOrder
  end: SortOrder
}

enum SortOrder {
  asc
  desc
}

enum EventTense {
  Current
  Future
  Past
}

type GetEventInvitedStatisticsResponse {
  total: Int!
  total_joined: Int!
  guests: [Guest!]!
  top_inviter: MongoID
  top_inviter_expanded: User
}

type Guest {
  invitation: MongoID!
  invited_by: MongoID!
  invited_by_expanded: User
  cancelled_by: MongoID
  cancelled_by_expanded: User
  joined: Boolean
  declined: Boolean

  """
  Exists only if joined from email
  """
  user: MongoID
  user_expanded: User

  """
  Exists only if invited via email but has not joined to be a user
  """
  email: String
}

type ListEventHostsResponse {
  hosts: [EventHost!]!
  total: Float!
}

type EventHost {
  _id: MongoID
  name: String!
  events_count: Float
  image_avatar: String
}

type EventApplicationAnswer {
  _id: MongoID!
  user: MongoID
  email: String
  question: MongoID!
  answer: String
  answers: [String!]
  question_expanded: EventApplicationQuestion!
}

type Applicant {
  _id: MongoID
  active: Boolean
  name: String
  email: String
  display_name: String
  calendly_url: String
  company_name: String
  date_of_birth: DateTimeISO
  description: String
  education_title: String
  ethnicity: String
  handle_farcaster: String
  handle_github: String
  handle_instagram: String
  handle_lens: String
  handle_linkedin: String
  handle_mirror: String
  handle_twitter: String
  image_avatar: String
  industry: String
  job_title: String
  pronoun: String
  new_gender: String
  tagline: String
  username: String
  wallets_new: JSON
  wallet_custodial: String
}

type EventApplicationExport {
  user: EventApplicationUserExport
  non_login_user: EventApplicationUserExport
  questions: [String!]!
  answers: [EventApplicationAnswerExport!]!
}

type EventApplicationUserExport {
  _id: MongoID!
  email: String!
  name: String
}

type EventApplicationAnswerExport {
  _id: MongoID!
  answer: String
}

type EventCheckin {
  _id: MongoID!
  active: Boolean!
  created_at: DateTimeISO!
  event: MongoID!
  user: MongoID
  email: String
  ticket: MongoID
  login_user: UserWithEmail
  non_login_user: NonloginUser
}

type UserWithEmail {
  _id: MongoID
  active: Boolean!
  created_at: DateTimeISO!
  updated_at: DateTimeISO!
  name: String!
  verified: Boolean
  phone: String
  phone_verified: Boolean
  email: String
  email_marketing: Boolean
  email_verified: Boolean
  country: String
  display_name: String
  first_name: String
  last_name: String
  type: UserType
  search_range: Float
  lemon_amount: Float!
  lemon_cap: Float!
  discovery: UserDiscoverySettings
  addresses: [Address!]
  age: Float
  blocked: [MongoID!]
  calendly_url: String
  currency: String
  company_address: Address
  company_name: String
  cover: MongoID
  date_of_birth: DateTimeISO
  description: String
  education_title: String
  ethnicity: String
  events: [MongoID!]
  expertise: [MongoID!]
  frequent_questions: [FrequentQuestion!]
  handle_facebook: String
  handle_farcaster: String
  handle_github: String
  handle_instagram: String
  handle_lens: String
  handle_linkedin: String
  handle_mirror: String
  handle_twitter: String
  image_avatar: String
  industry: String
  interests: [String!]
  job_title: String
  languages: [String!]
  layout_sections: [LayoutSection!]
  location_line: String
  music: [String!]
  offers: [UserOffer!]
  preferred_network: String
  pronoun: String
  new_gender: String
  new_photos: [MongoID!]
  service_offers: [MongoID!]
  tag_recommended: Boolean
  tag_site: Boolean
  tag_timeline: Boolean
  tag_verified: Boolean
  tagline: String
  timezone: String
  username: String
  settings: JSON
  wallets: [String!]
  wallets_new: JSON
  wallet_custodial: String
  attended: Float
  followers: Float
  following: Float
  friends: Float
  hosted: Float
  posts: Float
  discord_user_info: JSON
  farcaster_user_info: FarcasterUserInfo
  lemon_refresh_at: DateTimeISO
  fcm_tokens: [String!]
  matrix_localpart: String
  payment_verification: UserPaymentVerification
  url: String
  url_go: String
  daos: [UserDao!]
  data: JSON
  eventbrite_user_info: JSON
  google_user_info: JSON
  stripe_user_info: JSON
  terms_accepted_adult: Boolean
  terms_accepted_conditions: Boolean
  notification_filters: [JSON!]
  razorpay_customer: String
  shopify_user_info: JSON
  twitch_user_info: JSON
  twitter_user_info: JSON
  twitter2_user_info: JSON
  zoom_user_info: JSON
  telegram_user_info: JSON
  stripe_connected_account: StripeConnectedAccount
  farcaster_fid: Float
  quest_points: Float
  icebreakers: [UserIcebreaker!]
  service_offers_expanded: [UserServiceOffer]
  expertise_expanded: [UserExpertise]
  cover_expanded: File
  events_expanded(skip: Int! = 0, limit: Int! = 25): [Event]
  new_photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  blocked_expanded: [User]
}

type NonloginUser {
  _id: MongoID
  active: Boolean
  created_at: DateTimeISO
  updated_at: DateTimeISO
  name: String
  verified: Boolean
  phone: String
  phone_verified: Boolean
  email: String
  email_marketing: Boolean
  email_verified: Boolean
  country: String
  display_name: String
  first_name: String
  last_name: String
  type: UserType
  search_range: Float
  lemon_amount: Float
  lemon_cap: Float
  discovery: UserDiscoverySettings
  addresses: [Address!]
  age: Float
  blocked: [MongoID!]
  calendly_url: String
  currency: String
  company_address: Address
  company_name: String
  cover: MongoID
  date_of_birth: DateTimeISO
  description: String
  education_title: String
  ethnicity: String
  events: [MongoID!]
  expertise: [MongoID!]
  frequent_questions: [FrequentQuestion!]
  handle_facebook: String
  handle_farcaster: String
  handle_github: String
  handle_instagram: String
  handle_lens: String
  handle_linkedin: String
  handle_mirror: String
  handle_twitter: String
  image_avatar: String
  industry: String
  interests: [String!]
  job_title: String
  languages: [String!]
  layout_sections: [LayoutSection!]
  location_line: String
  music: [String!]
  offers: [UserOffer!]
  preferred_network: String
  pronoun: String
  new_gender: String
  new_photos: [MongoID!]
  service_offers: [MongoID!]
  tag_recommended: Boolean
  tag_site: Boolean
  tag_timeline: Boolean
  tag_verified: Boolean
  tagline: String
  timezone: String
  username: String
  settings: JSON
  wallets: [String!]
  wallets_new: JSON
  wallet_custodial: String
  attended: Float
  followers: Float
  following: Float
  friends: Float
  hosted: Float
  posts: Float
  discord_user_info: JSON
  farcaster_user_info: FarcasterUserInfo
  lemon_refresh_at: DateTimeISO
  fcm_tokens: [String!]
  matrix_localpart: String
  payment_verification: UserPaymentVerification
  url: String
  url_go: String
  daos: [UserDao!]
  data: JSON
  eventbrite_user_info: JSON
  google_user_info: JSON
  stripe_user_info: JSON
  terms_accepted_adult: Boolean
  terms_accepted_conditions: Boolean
  notification_filters: [JSON!]
  razorpay_customer: String
  shopify_user_info: JSON
  twitch_user_info: JSON
  twitter_user_info: JSON
  twitter2_user_info: JSON
  zoom_user_info: JSON
  telegram_user_info: JSON
  stripe_connected_account: StripeConnectedAccount
  farcaster_fid: Float
  quest_points: Float
  icebreakers: [UserIcebreaker!]
  service_offers_expanded: [UserServiceOffer!]
  expertise_expanded: [UserExpertise!]
  cover_expanded: File
  events_expanded: [Event!]
  new_photos_expanded: [File!]
  blocked_expanded: [User!]
}

input GetEventCheckinsInput {
  event: MongoID!
  users: [MongoID!]
  emails: [String!]
}

type EventCohostRequest {
  _id: MongoID!
  stamp: DateTimeISO!
  from: MongoID!
  event: MongoID!
  to: MongoID
  to_email: String
  state: EventCohostRequestState!
  from_expanded: User
  to_expanded: User
}

enum EventCohostRequestState {
  DECLINED
  ACCEPTED
  PENDING
}

input GetEventCohostRequestsInput {
  event: MongoID!
  state: EventCohostRequestState
}

type EventAttestation {
  event_address: String
  uid: String
  last_sync: DateTimeISO!
}

type EventAttestationDiff {
  event: EASEvent
  ticket_types: [EASTicketType!]
}

type EASEvent {
  _id: MongoID
  title: String!
  description: String
  uid: String
  detail_uid: String
  diff: [String!]
  creatorName: String
  creatorProfile: String
  date: String
  eventLink: String
  type: String
  cohosts: [EASEventCohost!]!
  tickets: Float!
}

type EASEventCohost {
  wallet: String!
  uid: String
  cohostName: String
  cohostProfile: String
  eventLink: String
}

type EASTicketType {
  _id: MongoID!
  title: String!
  description: String
  uid: String
  detail_uid: String
  eventName: String
  eventLink: String
  cost: String!
  currency: String
  provider: String
  diff: [String!]
  tickets: [EASTicket!]
}

type EASTicket {
  _id: MongoID!
  guest: String
  eventName: String
  eventLink: String
  ticket: String
  assignedBy: String
  wallet_address: String!
}

type EmailSetting {
  _id: MongoID!
  template: MongoID!
  owner: MongoID!
  context: JSON
  sendgrid_template_id: String
  custom_subject_html: String
  custom_body_html: String
  cc: [String!]
  disabled: Boolean
  scheduled_at: DateTimeISO
  recipient_types: [EmailRecipientType!]
  recipient_filters: EmailRecipientFilters
  sent_at: DateTimeISO
  recipients: [String!]
  opened: [EmailTracking!]
  type: EmailTemplateType!
  is_system_email: Boolean!
  subject_preview: String
  body_preview: String
  recipients_details: [RecipientDetail!]
}

enum EmailRecipientType {
  assigned
  attending
  registration
  invited
  ticket_type_whitelisted
  join_requester
  event_hosts
  ticket_cancelled
  ticket_issued
}

type EmailRecipientFilters {
  ticket_types: [MongoID!]
  join_request_states: [EventJoinRequestState!]
}

enum EventJoinRequestState {
  pending
  approved
  declined
}

type EmailTracking {
  email: String!
  stamp: DateTimeISO!
}

enum EmailTemplateType {
  invitation
  invitation_cancelled
  event_cancelled
  event_created_notification
  event_cohost_invitation
  join_request_approved
  join_request_approved_with_tickets
  join_request_declined
  join_requested
  post_rsvp
  ticket_issued
  ticket_received
  ticket_cancelled
  ticket_type_whitelisted
  crypto_payment_receipt
  updated
  feedback
  custom
  reminder
  user_contact_invite
  seller_store_order_pending
  buyer_store_order_pending
  buyer_store_order_declined
  buyer_store_order_accepted
  buyer_store_order_preparing
  buyer_store_order_delivered
  buyer_store_order_cancelled
  buyer_store_order_tracking
  space_add_admin_invitation
  space_add_ambassador_invitation
  space_add_subscriber_manually_invitation
  space_request_pinning_event
}

type RecipientDetail {
  name: String!
  email: String
  image_avatar: String
  _id: MongoID
}

type EventFeedbackSummary {
  rates: [RateSummary!]!
}

type RateSummary {
  rate_value: Int!
  count: Int!
}

type EventFeedback {
  user: MongoID
  email: String
  event: MongoID!
  rate_value: Float!
  comment: String
  created_at: DateTimeISO!
  user_info: User
}

type BasicUserInfo {
  _id: MongoID!
  name: String!
  image_avatar: String
  username: String
  job_title: String
  company_name: String
  matrix_localpart: String
}

type EventGuestDetail {
  user: EventGuestUser!
  ticket: Ticket
  payment: EventGuestPayment
  application: [EventApplicationQuestionAndAnswer!]
  join_request: EventJoinRequest
}

type EventGuestUser {
  _id: MongoID
  name: String
  email: String
  image_avatar: String
}

type Ticket {
  _id: MongoID!
  shortid: String!
  created_at: DateTimeISO!
  event: MongoID!
  type: MongoID!
  accepted: Boolean
  acquired_by: MongoID
  cancelled_by: MongoID
  acquired_by_email: String
  assigned_email: String
  assigned_to: MongoID
  invited_by: MongoID
  payment_id: MongoID
  metadata: JSON
  assigned_to_info: ConfidentialUserInfo
  assigned_to_expanded: User
  event_expanded: Event
  type_expanded: EventTicketType
  acquired_tickets: [Ticket!]
  checkin: EventCheckin

  """
  This object includes the email when compared to the `assigned_to_expanded` field.
  """
  assignee_expanded: UserWithEmail
  acquired_expanded: UserWithEmail
}

type EventGuestPayment {
  _id: MongoID!
  stamps: JSON!
  amount: String!
  fee: String
  currency: String!
  state: NewPaymentState!
  user: MongoID
  buyer_info: BuyerInfo
  account: MongoID!
  ref_data: JSON
  billing_info: BillingInfo
  transfer_metadata: JSON
  transfer_params: JSON
  failure_reason: String
  attempting_refund: Boolean
  account_expanded: NewPaymentAccount
  due_amount: String
  buyer_user: UserWithEmail
  formatted_due_amount: String
  formatted_total_amount: String
  formatted_discount_amount: String
  formatted_fee_amount: String
  stripe_payment_info: StripePaymentInfo
  crypto_payment_info: CryptoPaymentInfo
}

enum NewPaymentState {
  created
  initialized
  failed
  await_capture
  succeeded
  refunded
}

type BuyerInfo {
  email: String!
  name: String
}

type BillingInfo {
  _id: MongoID
  recipient_name: String
  street_1: String
  street_2: String
  city: String
  region: String
  postal: String
  country: String
  title: String
  phone: String
  longitude: Float
  latitude: Float
  additional_directions: String
  email: String
  firstname: String
  lastname: String
}

type StripePaymentInfo {
  card: StripeCardInfo
  payment_intent: String!
}

type StripeCardInfo {
  brand: String
  last4: String
}

type CryptoPaymentInfo {
  network: String
  tx_hash: String
}

type EventApplicationQuestionAndAnswer {
  question: String
  answer: String
  answers: [String!]
}

type EventJoinRequest {
  _id: MongoID!
  created_at: DateTimeISO!
  event: MongoID!
  user: MongoID
  email: String
  state: EventJoinRequestState!
  decided_at: DateTimeISO
  decided_by: MongoID
  requested_tickets: [RequestedTicket!]
  payment_id: MongoID
  user_expanded: UserWithEmail
  payment: JoinRequestPayment
  event_expanded: Event
  decided_by_expanded: User
  ticket_types_expanded: [EventTicketType]
  non_login_user: NonloginUser
}

type RequestedTicket {
  ticket_type: MongoID!
  count: Float!
}

type JoinRequestPayment {
  _id: MongoID!
  state: NewPaymentState!
  buyer_info: BuyerInfo
  ref_data: JSON
  transfer_metadata: JSON
}

type EventInvitation {
  _id: MongoID!
  event: MongoID!
  inviters: [MongoID!]!
  user: MongoID
  email: String
  phone: String
  created_at: DateTimeISO!
  status: InvitationResponse!
}

enum InvitationResponse {
  PENDING
  DECLINED
  ACCEPTED
  CANCELLED
}

type GenerateEventInvitationUrlResponse {
  shortid: String!
  tk: String
}

type EventInvitationUrl {
  event: MongoID!
  user: MongoID!
}

type GetEventJoinRequestsResponse {
  total: Int!
  records: [EventJoinRequest!]!
}

type EventPaymentSummary {
  currency: String!
  decimals: Float!
  amount: String!
  transfer_amount: String!
  pending_transfer_amount: String!
}

type EventQuestion {
  _id: MongoID!
  stamp: DateTimeISO!
  event: MongoID!
  user: MongoID!
  question: String!
  likes: Int!
  session: MongoID
  user_expanded: User
  liked: Boolean
}

input GetEventQuestionsInput {
  event: MongoID!
  id_lt: MongoID
  limit: Int! = 20
  sort: GetEventQuestionInputSort! = _id
}

enum GetEventQuestionInputSort {
  _id
  likes
}

input GenerateRecurringDatesInput {
  start: DateTimeISO!
  utcOffsetMinutes: Float!
  repeat: RecurringRepeat!
  dayOfWeeks: [Int!]
  end: DateTimeISO
  count: Float
}

enum RecurringRepeat {
  daily
  weekly
  monthly
}

type EventRewardUse {
  _id: MongoID!
  active: Boolean!
  event: MongoID!
  reward_id: MongoID!
  reward_number: Float!
  user: MongoID!
  user_expanded: User
}

input GetEventRewardUsesInput {
  event: MongoID!
  user: MongoID!
}

type EventSessionReservation {
  user: MongoID!
  event: MongoID!
  session: MongoID!
  ticket_type: MongoID
  user_expanded: User
}

input GetEventSessionReservationsInput {
  event: MongoID
}

type EventSessionReservationSummary {
  session: MongoID!
  ticket_type: MongoID
  count: Float!
}

input GetEventSessionReservationSummaryInput {
  event: MongoID!
  session: MongoID
}

type EventTicketSaleResponse {
  last_update: DateTimeISO!
  sales: [SaleAmountResponse!]!
}

type SaleAmountResponse {
  currency: String!
  amount: String!
  decimals: Int!
}

type GetEventTicketTypesResponse {
  limit: Float!
  ticket_types: [PurchasableTicketType!]!
  discount: TicketDiscount
}

type PurchasableTicketType {
  _id: MongoID!
  active: Boolean
  private: Boolean
  limited: Boolean
  event: MongoID!
  title: String!
  category: MongoID
  default: Boolean
  address_required: Boolean
  description: String
  description_line: String
  external_ids: [String!]
  offers: [EventOffer!]
  photos: [MongoID!]
  position: Int
  approval_required: Boolean
  prices: [EventTicketPrice!]!
  discountable: Boolean!
  limit: Float!
  whitelisted: Boolean
  photos_expanded(skip: Int! = 0, limit: Int! = 25): [File]
  category_expanded: EventTicketCategory
}

type TicketDiscount {
  discount: String!
  limit: Float!
  ratio: Float!
}

input GetEventTicketTypesInput {
  email: String
  event: MongoID!
  discount: String
}

type EventbriteEvent {
  id: String!
  title: String!
  status: String!
  logo_url: String
  description: String
  start: DateTimeISO!
  end: DateTimeISO!
  stamp: DateTimeISO!
}

input GetEventbriteEventsInput {
  status: EventbriteEventStatus
  order: EventbriteEventOrder
}

enum EventbriteEventStatus {
  DRAFT
  LIVE
  CANCELED
  STARTED
  ENDED
}

enum EventbriteEventOrder {
  CREATED_ASC
  CREATED_DESC
}

input FileLinkInput {
  model: String!
  id: MongoID!
  path: String
  type: FileLinkType
}

input GetFrequentQuestionsInput {
  type: [FrequentQuestionType!]!
}

type GuildRoom {
  _id: MongoID!
  created_at: DateTimeISO!
  created_by: MongoID!
  title: String!
  guild_id: Float!
  guild_role_ids: [Int!]
  guild_role_require_all: Boolean
  joins: Float
  matrix_room_id: String!
  created_by_expanded: User
}

type NewPayment {
  _id: MongoID!
  stamps: JSON!
  amount: String!
  fee: String
  currency: String!
  state: NewPaymentState!
  user: MongoID
  buyer_info: BuyerInfo
  account: MongoID!
  ref_data: JSON
  billing_info: BillingInfo
  transfer_metadata: JSON
  transfer_params: JSON
  failure_reason: String
  attempting_refund: Boolean
  account_expanded: NewPaymentAccount
  tickets: [TicketBase!]
  ticket_types_expanded: [EventTicketType]
  due_amount: String
  buyer_user: UserWithEmail
  formatted_due_amount: String
  formatted_total_amount: String
  formatted_discount_amount: String
  formatted_fee_amount: String
  stripe_payment_info: StripePaymentInfo
  crypto_payment_info: CryptoPaymentInfo
  application: [EventApplicationQuestionAndAnswer!]
  join_request: EventJoinRequestBase
}

type EventJoinRequestBase {
  _id: MongoID!
  created_at: DateTimeISO!
  event: MongoID!
  user: MongoID
  email: String
  state: EventJoinRequestState!
  decided_at: DateTimeISO
  decided_by: MongoID
  requested_tickets: [RequestedTicket!]
  payment_id: MongoID
}

input FilterPaymentStateInput {
  eq: NewPaymentState
  in: [NewPaymentState!]
  nin: [NewPaymentState!]
}

type PaymentRefundSignature {
  signature: String!

  """
  The args that will be supplied to the contract refund function
  """
  args: [JSON!]!
}

type FiatCurrency {
  code: String!
  decimals: Float!
}

type Currency {
  code: String!
  decimals: Float!
}

type Chain {
  active: Boolean
  platform: String!
  chain_id: String!
  name: String!
  code_name: String!
  rpc_url: String!
  block_explorer_url: String
  block_explorer_name: String
  block_explorer_for_tx: String
  block_explorer_for_token: String
  block_explorer_for_address: String
  block_time: Float!
  safe_confirmations: Float!
  logo_url: String
  tokens: [Token!]
  access_registry_contract: String
  poap_contract: String
  marketplace_contract: String
  marketplace_version: Int
  biconomy_api_key: String
  ens_registry: String
  proxy_admin_contract: String
  payment_config_registry_contract: String
  escrow_manager_contract: String
  relay_payment_contract: String
  stake_payment_contract: String
  reward_registry_contract: String
  donation_registry_contract: String
  eas_event_contract: String
  eas_graphql_url: String
  aragon_network: String
  axelar_chain_name: String
}

type Token {
  active: Boolean
  name: String!
  symbol: String!
  decimals: Float!
  contract: String!
  logo_url: String
}

type Post {
  _id: MongoID!
  created_at: DateTimeISO!
  user: MongoID!
  visibility: PostVisibility!
  comments: Float
  published: Boolean
  text: String
  reactions: Float
  ref_type: PostRefType
  ref_id: String
  has_reaction: Boolean
  ref_event: Event
  ref_file: File
  user_expanded: User
}

enum PostVisibility {
  PUBLIC
  FRIENDS
  FOLLOWERS
  MENTIONS
}

enum PostRefType {
  EVENT
  FILE
}

input GetPostsInput {
  _id: MongoID
  user: MongoID
  published: Boolean
  created_at: GetPostsCreatedAtInput
}

input GetPostsCreatedAtInput {
  gte: DateTimeISO
  lte: DateTimeISO
}

type Newsfeed {
  offset: Float!
  posts: [Post!]!
}

type Notification {
  _id: MongoID!
  created_at: DateTimeISO!
  type: NotificationType!
  from: MongoID
  title: String
  message: String
  image_url: String
  data: JSON
  ref_event: MongoID
  ref_user: MongoID
  ref_store_order: MongoID
  ref_room: MongoID
  ref_space: MongoID
  is_seen: Boolean
  from_expanded: User
  ref_user_expanded: User
  ref_event_expanded: Event
  ref_store_order_expanded: StoreOrder
  ref_room_expanded: Room
  ref_space_expanded: Space
}

enum NotificationType {
  event_announce
  event_invite
  event_approve
  event_cohost_request
  event_cohost_request_announce
  event_broadcast_created
  event_broadcast_deactivated
  event_broadcast_deleted
  event_broadcast_started
  user_discovery_match
  user_friendship_request
  user_friendship_request_accept
  user_contact_signup
  event_request_created
  event_invite_attending
  event_declined
  event_cancellation
  stripe_connected
  admin_payment_verification
  chat_message
  event_broadcast_ended
  event_broadcast_rescheduled
  event_chat_announce
  event_donation
  event_attestation_sync_completed
  event_invite_verify_accept_request
  event_invite_verify_request
  event_request_approved
  event_request_declined
  event_unlock_verify_accept_request
  event_unlock_verify_request
  event_update
  ticket_assigned
  ticket_cancelled
  payment_authorized
  payment_failed
  payment_refunded
  payment_succeeded
  payments_captured_summary
  payments_wired_summary
  place_reservation_delete
  place_reservation_request
  place_reservation_request_accept
  place_reservation_request_decline
  reservation_accept
  room_invite
  room_started
  safe_vault_init_failed
  safe_vault_init_success
  store_order_accepted
  store_order_awaiting_pickup
  store_order_cancelled
  store_order_declined
  store_order_delivered
  store_order_delivery_confirmed
  store_order_in_transit
  store_order_pending
  store_order_preparing
  space_member_added
  space_event_pin_request
}

type StoreOrder {
  _id: MongoID
  active: Boolean!
  stamp: DateTimeISO!
  stamp_created: DateTimeISO!
  state: StoreOrderState!
  user: MongoID!
  store: MongoID!
  order_nr: Float!
  address: Address!
  value: Float!
  amount: Float!
  currency: String!
  delivery_option: DeliveryOption!
  delivery_cost: Float!
  fulfillment_address: Address
  pickup_address: Address
  delivery_option_cost_waived: Boolean
  sales_tax: SalesTax
  easyship_rates: [JSON!]
  easyship_courier_id: String
  easyship_shipment_id: String
  easyship_selected_courier: JSON
  label_state: String
  label_error: String
  label_url: String
  promotion: MongoID
  tracking_url: String
  store_expanded: Store
  user_expanded: User
  history: [StoreOrderHistoryItem!]
  items: [StoreOrderItem!]!
}

enum StoreOrderState {
  created
  pending
  declined
  accepted
  preparing
  awaiting_pickup
  in_transit
  delivered
  delivery_confirmed
  cancelled
}

type StoreOrderHistoryItem {
  stamp: DateTimeISO!
  state: String!
  user: MongoID
  user_expanded: User
}

type StoreOrderItem {
  _id: MongoID!
  state: StoreOrderItemState!
  product_variant: MongoID!
  product_groups: JSON!
  count: Float!
  value: Float!
  amount: Float!
  delivery_option: DeliveryOption
  delivery_cost: Float
  delivery_option_cost_waived: Boolean
  promotion: Float
  promotion_amount: Float
  inventory: Float
  fee: Float
  tax: Float
  tracking_url: String
  product: StoreProduct!
}

enum StoreOrderItemState {
  pending
  accepted
  declined
}

type Room {
  _id: MongoID!
  shortid: String!
  active: Boolean!
  stamp: DateTimeISO!
  title: String!
  state: RoomState!
  start: DateTimeISO!
  host: MongoID!
  cohosts: [MongoID!]
  staged_users: [MongoID!]
  staged_uids: [Float!]
  stage_invitees: [MongoID!]
  stage_requesters: [MongoID!]
  attending_users: [MongoID!]
  access_users: [MongoID!]
  access_requesters: [MongoID!]
  url: String!
  url_go: String!
  staged_size: Float
  audience_size: Float
  private: Boolean
  verify: Boolean
  description: String
  event: MongoID
  payment_direct: Boolean
  photos: [MongoID!]
  stage_open: Boolean
  theme_background_photo: MongoID
  theme_color: String
  theme_layout: Float
  video: Video
  highlight_stores: [MongoID!]
  highlight_events: [MongoID!]
  highlight_rooms: [MongoID!]
  highlight_users: [MongoID!]
  used: Boolean
  broadcasters_count: Float
  audience_total: Float
  creator_last_seen_at: DateTimeISO
  offers: [RoomOffer!]
  has_access: Boolean
  host_expanded: User
  cohosts_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  staged_users_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
  stage_invitees_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
  stage_requesters_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
  attending_users_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
  access_users_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
  access_requesters_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
  event_expanded: Event
  photos_expanded(skip: Int! = 0, limit: Int! = 25): [File!]
  theme_background_photo_expanded: File
  highlight_stores_expanded(skip: Int! = 0, limit: Int! = 25): [Store!]
  highlight_events_expanded(skip: Int! = 0, limit: Int! = 25): [Event!]
  highlight_rooms_expanded(skip: Int! = 0, limit: Int! = 25): [Room!]
  highlight_users_expanded(skip: Int! = 0, limit: Int! = 25): [User!]
}

enum RoomState {
  scheduled
  started
  ended
}

type RoomOffer {
  _id: MongoID
  provider: OfferProvider!
  provider_network: String!
  provider_id: String!
  position: Float
}

input NotificationTypeFilterInput {
  eq: NotificationType
  in: [NotificationType!]
  nin: [NotificationType!]
}

type OAuth2Client {
  client_id: String!
  client_secret: String
  client_name: String!
  skip_consent: Boolean
  logo_uri: String
  token_endpoint_auth_method: String
  redirect_uris: [String!]
  grant_types: [String!]!
  response_types: [String!]
  scope: String!
  audience: [String!]!
  allowed_cors_origins: [String!]!
  created_at: DateTimeISO!
  updated_at: DateTimeISO!
  metadata: JSON
  post_logout_redirect_uris: [String!]
  authorization_code_grant_access_token_lifespan: String
  authorization_code_grant_id_token_lifespan: String
  authorization_code_grant_refresh_token_lifespan: String
  client_credentials_grant_access_token_lifespan: String
  implicit_grant_access_token_lifespan: String
  implicit_grant_id_token_lifespan: String
  jwt_bearer_grant_access_token_lifespan: String
  refresh_token_grant_id_token_lifespan: String
  refresh_token_grant_access_token_lifespan: String
  refresh_token_grant_refresh_token_lifespan: String
}

type Offer {
  _id: MongoID
  provider: OfferProvider!
  provider_network: String!
  provider_id: String!
  position: Float
  color: String
}

enum OfferType {
  HOME
  POAP
}

type PointGroup {
  first_level_group: Group
  second_level_groups: [Group]!
  points: Float
  count: Float
  completed: Float
}

type Group {
  _id: MongoID!
  title: String!
  sub_title_1: String
  sub_title_2: String
  position: Float!
}

type PointConfigInfo {
  _id: MongoID!
  type: PointType!
  title: String
  points: Float!
  first_time_only: Boolean
  first_level_group: MongoID
  second_level_group: MongoID
  trackings: [PointTrackingInfo!]!
}

enum PointType {
  verify_email
  config_username
  config_display_name
  config_profile_photo
  config_bio
  connect_wallet
  connect_farcaster
  connect_stripe
  connect_eventbrite
  signup_on_mobile_app
  create_post
  per_post_has_more_than_n_likes
  per_published_event
  every_nth_rsvp
  event_attestation
  update_event_attestation
  per_guest_checkin
  per_paid_ticket_tier_created
  per_ticket_sold
  per_event_rsvp
  per_event_checkin
  invitee_rsvp_event
}

type PointTrackingInfo {
  _id: MongoID!
  config: MongoID!
  points: Float!
  created_at: DateTimeISO!
}

input GetRoomsInput {
  skip: Int! = 0
  limit: Int! = 25
  state: GetRoomsInputState
  creator: MongoID
  event: MongoID
}

input GetRoomsInputState {
  eq: RoomState
  in: [RoomState!]
  nin: [RoomState!]
}

type RoomCredentials {
  uid: Float!
  token: String!
}

input GetRoomCredentialsInput {
  _id: MongoID!
  role: GetRoomCredentialsInputRole!
  password: String
}

enum GetRoomCredentialsInputRole {
  SUBSCRIBER
  PUBLISHER
}

type FreeSafeInitInfo {
  current: Int!
  max: Int!
}

type RawTransaction {
  to: String!
  value: String!
  data: String!
}

input GetInitSafeTransactionInput {
  owners: [String!]!
  threshold: Int!
  network: String!
}

type Site {
  _id: MongoID!
  active: Boolean!
  client: String!
  hostnames: [String!]
  title: String!
  daos: [SiteDao!]
  description: String!
  access_pass: AccessPass
  header_metas: [SiteHeaderMeta!]
  header_links: [SiteHeaderLink!]
  footer_scripts: [SiteFooterScript!]
  ai_config: MongoID
  event: MongoID
  farcaster_channel_url: String
  onboarding_steps: [SiteOnboardingStep!]
  owners: [MongoID!]
  partners: [MongoID!]
  user: MongoID
  share_url: JSON
  favicon_url: String
  logo_url: String
  logo_mobile_url: String
  passports: [SitePassport!]
  privacy_url: String
  theme_data: JSON
  theme_type: String
  text: JSON
  visibility: JSON
  user_expanded: User
}

type SiteDao {
  network: String!
  address: String!
  name: String!
  icon: String
}

type SiteHeaderMeta {
  key: String
  name: String
  property: String
  content: String
}

type SiteHeaderLink {
  rel: SiteHeaderLinkRel
  href: String
}

enum SiteHeaderLinkRel {
  Stylesheet
  Icon
}

type SiteFooterScript {
  strategy: SiteFooterScriptStrategy
  src: String
  id: String
  children: String
}

enum SiteFooterScriptStrategy {
  AfterInteractive
  LazyOnload
  BeforeInteractive
}

type SiteOnboardingStep {
  name: SiteOnboardingStepName!
  data: JSON
}

enum SiteOnboardingStepName {
  AdultCheck
  ConditionsCheck
  Username
  Wallet
  WalletInput
  Photo
  About
  Interests
  Feeds
  Custom
  Done
  DisplayName
  Job
  Biography
  SocialHandles
}

type SitePassport {
  name: String!
  image: String!
  logo: String!
  baseV1Address: String!
  baseV1ChainId: Float!
  passportV1CallAddress: String!
  ssiGroup: String!
  passportV1AxelarAddress: JSON
  crowdfundAddress: JSON
}

enum SpaceRole {
  unsubscriber
  subscriber
  ambassador
  admin
  creator
}

type ListSpaceMembersResponse {
  items: [SpaceMember!]!
  total: Int!
}

type SpaceMember {
  _id: MongoID
  user: MongoID
  user_name: String
  email: String
  space: MongoID
  role: SpaceRole
  state: SpaceMembershipState
  visible: Boolean
  role_changed_at: DateTimeISO
  deleted_at: DateTimeISO
  user_expanded: UserWithEmail
  event_count: Float
  checkin_count: Float
  tags: [SpaceTagBase!]
}

enum SpaceMembershipState {
  invited
  requested
  rejected
  joined
}

input SortInput {
  field: String!

  """
  - 1 for increasing
  - -1 for descreasing
  """
  order: Int! = 1
}

type ListSpaceRoleFeaturesResponse {
  features: [Feature!]!
  codes: [FeatureCode!]!
}

type Feature {
  code: FeatureCode!
  title: String!
}

enum FeatureCode {
  DataDashboard
  CSVGuestList
  GuestListDashboard
  EventSettings
  TicketingSettings
  EmailManager
  PromotionCodes
  CollectibleData
  Checkin
  ViewSpace
  ManageSpace
  ViewSpaceMembership
  ManageSpaceMembership
  ViewSpaceEvent
  ManageSpaceEvent
  ViewSpaceTag
  ManageSpaceTag
  ManageSpaceTokenGate
}

input AddressInput {
  _id: MongoID
  recipient_name: String
  street_1: String
  street_2: String
  city: String
  region: String
  postal: String
  country: String
  title: String
  phone: String
  longitude: Float
  latitude: Float
  additional_directions: String
}

type StoreBucketItem {
  _id: MongoID!
  active: Boolean!
  stamp: DateTimeISO!
  user: MongoID!
  store: MongoID!
  product: MongoID!
  product_variant: MongoID!
  product_groups: JSON!
  count: Float!
  product_expanded: StoreProduct
  store_expanded: Store
}

type StoreCategory {
  _id: MongoID!
  active: Boolean!
  stamp: DateTimeISO!
  store: MongoID!
  title: String!
  description: String
  parents: [MongoID!]
}

input StoreOrderStateFilterInput {
  eq: StoreOrderState
  in: [StoreOrderState!]
  nin: [StoreOrderState!]
}

type StripeCard {
  _id: MongoID!
  active: Boolean!
  stamp: DateTimeISO!
  provider_id: String!
  user: MongoID!
  brand: String!
  name: String!
  last4: String!
}

type StripeAccountCapability {
  id: String!
  capabilities: [Capability!]!
}

type Capability {
  type: StripeCapabilityType!
  detail: CapabilityDetail!
}

enum StripeCapabilityType {
  card
  apple_pay
  google_pay
}

type CapabilityDetail {
  available: Boolean!
  display_preference: DisplayPreference!
}

type DisplayPreference {
  overridable: Boolean!
  preference: StripeAccountCapabilityDisplayPreferencePreference!
  value: StripeAccountCapabilityDisplayPreferenceValue!
}

enum StripeAccountCapabilityDisplayPreferencePreference {
  on
  off
  none
}

enum StripeAccountCapabilityDisplayPreferenceValue {
  on
  off
}

type ScanChannelsResult {
  offset_date: Float!
  offset_id: Float!
  user: TgUser
  channels: [TelegramChannel!]
}

type TgUser {
  id: String!
  accessHash: String!
  self: Boolean
  contact: Boolean
  mutualContact: Boolean
  deleted: Boolean
  verified: Boolean
  restricted: Boolean
  min: Boolean
  support: Boolean
  scam: Boolean
  applyMinPhoto: Boolean
  fake: Boolean
  attachMenuEnabled: Boolean
  firstName: String
  lastName: String
  username: String
  phone: String
  langCode: String
}

input ScanChannelsInput {
  offset_date: Float!
  offset_id: Float!
}

type PricingInfo {
  discount: String!
  subtotal: String!
  total: String!
  deposit_infos: [EscrowDepositInfo!]
  payment_accounts: [PaymentAccountInfo!]!
}

type EscrowDepositInfo {
  minimum_percent: Float!
  minimum_amount: String!
}

type PaymentAccountInfo {
  _id: MongoID!
  active: Boolean!
  created_at: DateTimeISO!
  user: MongoID!
  type: PaymentAccountType!
  title: String
  provider: NewPaymentProvider
  account_info: AccountInfo!
  escrow: EscrowDepositInfo
  relay: RelayPaymentInfo
  fee: String
}

type RelayPaymentInfo {
  payment_splitter_contract: String!
}

input CalculateTicketsPricingInput {
  buyer_info: BuyerInfoInput
  connect_wallets: [ConnectWalletInput!]
  event: MongoID!
  items: [PurchasableItem!]!
  inviter: MongoID
  user_info: UserInput
  currency: String!
  discount: String
}

input BuyerInfoInput {
  email: String!
  name: String
}

input ConnectWalletInput {
  platform: BlockchainPlatform!
  token: String!
  signature: String!
}

input PurchasableItem {
  id: MongoID!
  count: Int!
}

input UserInput {
  name: String
  phone: String
  email_marketing: Boolean
  display_name: String
  search_range: Float
  discovery: UserDiscoverySettingsInput
  addresses: [AddressInput!]
  calendly_url: String
  currency: String
  company_address: AddressInput
  company_name: String
  cover: MongoID
  date_of_birth: DateTimeISO
  description: String
  education_title: String
  ethnicity: String
  events: [MongoID!]
  expertise: [MongoID!]
  frequent_questions: [FrequentQuestionInput!]
  handle_facebook: String
  handle_farcaster: String
  handle_github: String
  handle_instagram: String
  handle_lens: String
  handle_linkedin: String
  handle_mirror: String
  handle_twitter: String
  icebreakers: [UserIcebreakerInput!]
  industry: String
  interests: [String!]
  job_title: String
  languages: [String!]
  layout_sections: [LayoutSectionInput!]
  music: [String!]
  offers: [UserOfferInput!]
  preferred_network: String
  pronoun: String
  new_gender: String
  new_photos: [MongoID!]
  service_offers: [MongoID!]
  tagline: String
  timezone: String
  username: String
  settings: JSON
  daos: [UserDaoInput!]
  data: JSON
  terms_accepted_adult: Boolean
  terms_accepted_conditions: Boolean
  notification_filters: [JSON!]
  email: String
}

input UserDiscoverySettingsInput {
  enabled: Boolean!
  min_age: Float!
  max_age: Float!
}

input FrequentQuestionInput {
  _id: MongoID
  type: [FrequentQuestionType!]!
  question: String!
  answer: String!
  position: Float
  tag: String
}

input UserIcebreakerInput {
  _id: MongoID
  question: MongoID!
  value: String!
}

input LayoutSectionInput {
  id: String
  hidden: Boolean
}

input UserOfferInput {
  _id: MongoID
  provider: OfferProvider!
  provider_network: String!
  provider_id: String!
  position: Float
  auto: Boolean
}

input UserDaoInput {
  network: String!
  address: String!
}

type GetMyTicketsResponse {
  tickets: [Ticket!]!
  payments: [PaymentRefundInfo!]
}

type PaymentRefundInfo {
  _id: MongoID!
  amount: String!
  currency: String!
  state: NewPaymentState!
  attempting_refund: Boolean

  """
  If null is returned then this payment does not support refund
  """
  refund_policy: PaymentRefundPolicy

  """
  Null for undeterminated, true if requirement met, otherwise false
  """
  refund_requirements_met: Boolean
  refund_info: RefundInfo
  payment_account: NewPaymentAccount!
}

type PaymentRefundPolicy {
  percent: Float!

  """
  Whether all requirements must be met
  """
  satisfy_all: Boolean
  requirements: RefundRequirements
}

type RefundRequirements {
  checkin_before: DateTimeISO
}

type RefundInfo {
  available_amount: String!
  refunded: Boolean
}

type TicketStatistics {
  all: Float!
  checked_in: Float!
  invited: Float!
  issued: Float!
  cancelled: Float!
  applicants: [JoinRequestStatistic!]!
  not_checked_in: Float!
  ticket_types: [TicketStatisticPerTier!]!
}

type JoinRequestStatistic {
  state: EventJoinRequestState!
  count: Float!
}

type TicketStatisticPerTier {
  ticket_type: MongoID!
  ticket_type_title: String!
  count: Float!
}

type ExportedTickets {
  tickets: [TicketExport!]!
  count: Float!
}

type TicketExport {
  _id: MongoID!
  shortid: String!
  assigned_email: String
  assigned_to: MongoID
  buyer_name: String
  buyer_first_name: String
  buyer_last_name: String
  buyer_email: String
  ticket_category: String
  ticket_type: String
  quantity: Float!
  payment_amount: String
  discount_amount: String
  currency: String
  discount_code: String
  purchase_date: DateTimeISO!
  payment_provider: String
  payment_id: MongoID
  checkin_date: DateTimeISO
  is_assigned: Boolean
  assignee_email: String
  is_issued: Boolean
  issued_by: String
  is_claimed: Boolean
  active: Boolean
  cancelled_by: String
  buyer_wallet: String
  buyer_id: MongoID
  buyer_avatar: String
  buyer_username: String
  ticket_type_id: MongoID
}

input PaginationInput {
  skip: Int! = 0
  limit: Int! = 25
}

type GetUserContactsResponse {
  items: [UserContact!]!
  total: Int!
  counts: JSON
}

type UserContact {
  _id: MongoID!
  created_at: DateTimeISO!
  user: MongoID!
  first_name: String
  last_name: String
  email: String
  phone: String
  contact: MongoID
  converted_at: DateTimeISO
  invited_at: DateTimeISO
  invited_count: Float
  tags: [String!]
  contact_expanded: User
}

input GetUserContactsInput {
  tags: [String!]
  invited_at_gt: DateTimeISO
  search: String
}

type UserDiscovery {
  _id: MongoID!
  stamp: DateTimeISO!
  user: MongoID!
  min_age: Float!
  max_age: Float!
  search_range: Float!
  selected: [MongoID!]!
  event: MongoID
  selected_expanded: [User]
}

type UserDiscoverySwipe {
  _id: MongoID!
  stamp: DateTimeISO!
  user1: MongoID!
  user2: MongoID!
  state: UserDiscoverySwipeState!
  source: UserDiscoverySwipeSource!
  message: String
  decision1: UserDiscoverySwipeDecision
  decision2: UserDiscoverySwipeDecision
  other: MongoID
  other_expanded: User
}

enum UserDiscoverySwipeState {
  undecided
  declined
  matched
  pending
}

enum UserDiscoverySwipeSource {
  discovery
  live
}

enum UserDiscoverySwipeDecision {
  accept
  decline
}

type UserFollow {
  _id: MongoID!
  created_at: DateTimeISO!
  follower: MongoID!
  followee: MongoID!
  follower_expanded: User
  followee_expanded: User
}

input GetUserFollowsInput {
  follower: MongoID
  followee: MongoID
  follower_search: String
  followee_search: String
}

type GetUserFriendshipsResponse {
  items: [UserFriendship!]!
  total: Int!
}

type UserFriendship {
  _id: MongoID!
  created_at: DateTimeISO!
  user1: MongoID!
  user2: MongoID!
  state: UserFriendshipState!
  types: JSON
  other: MongoID
  other_expanded: User
  type: UserFriendshipType
}

enum UserFriendshipState {
  accepted
  pending
}

enum UserFriendshipType {
  crew
  tribe
}

input GetUserFriendshipsInput {
  user1: MongoID
  user2: MongoID
  state: UserFriendshipState
  user: MongoID
  other: MongoID
  other_wallets: Boolean
  other_search: String
  type: UserFriendshipType
}

type UserPaymentVerificationInfo {
  conditions: [UserPaymentVerificationCondition!]!
  eligible: Boolean!
  verified: Boolean!
}

type UserPaymentVerificationCondition {
  title: String!
  prop: String!
  satisfied: Boolean!
}

type UserWalletRequest {
  message: String!
  token: String!
}

type EventVoting {
  _id: MongoID!
  hidden: Boolean
  state: EventVotingState!
  start: DateTimeISO!
  end: DateTimeISO!
  title: String!
  description: String
  stage: String
  timezone: String
  speakers: [User!]!
  voting_options: [VotingOption!]!
  selected_option: String
}

enum EventVotingState {
  not_started
  starting
  paused
  closed
}

type VotingOption {
  option_id: String!
  voters: [User!]!
}

type ListEventStakePaymentsResponse {
  items: [EventStakePayment!]!
  total: Int!
}

type EventStakePayment {
  _id: MongoID!
  currency: String!
  staker: StakeUser!
  ticket_count: Float!
  formatted_stake_amount: String!
  refund_requirements_met: Boolean
  state: StakeState!
  network: String!
}

type StakeUser {
  _id: MongoID
  name: String
  email: String
  display_name: String
  image_avatar: String
  wallet: String!
}

enum StakeState {
  locked
  defaulted
  unstaked
  slashed
  unlocked
}

type StakePaymentStatistics {
  total: Int!
  slash_states: [StakePaymentStateStatistic!]!
  slash_infos: [SlashInfo!]!
}

type StakePaymentStateStatistic {
  state: StakeState!
  count: Int!
}

type SlashInfo {
  vault: String!
  account_info: NewPaymentAccount
  slashable_payments: [MongoID!]!
  payouts: [SlashPayout!]!
}

type SlashPayout {
  currency: String!
  formatted_amount: String!
}

type GetSpaceEventRequestsResponse {
  total: Int!
  records: [SpaceEventRequest!]!
}

type SpaceEventRequest {
  _id: MongoID!
  created_at: DateTimeISO!
  created_by: MongoID
  space: MongoID!
  event: MongoID!
  tags: [MongoID!]
  state: SpaceEventRequestState!
  decided_at: DateTimeISO
  decided_by: MongoID
  event_expanded: Event
}

enum SpaceEventRequestState {
  pending
  approved
  declined
}

type TokenRewardVault {
  _id: MongoID!
  title: String!
  user: MongoID!
  network: String!
  address: String!
  tokens: [RewardToken!]
}

type RewardToken {
  address: String!
  symbol: String!
  name: String
  decimals: Int!
  icon: MongoID
  icon_url: String
  icon_expanded: File
}

type CheckinTokenRewardSetting {
  _id: MongoID!
  user: MongoID!
  title: String!
  photo: MongoID
  vault: MongoID!
  currency_address: String!
  event: MongoID!
  rewards: [TicketTypeReward!]!
  photo_expanded: File
  vault_expanded: TokenRewardVault
}

type TicketTypeReward {
  ticket_type: MongoID!
  reward_per_ticket: String!
  reward_id: String!
  ticket_type_expanded: EventTicketType
}

type TicketTokenRewardSetting {
  _id: MongoID!
  user: MongoID!
  title: String!
  photo: MongoID
  vault: MongoID!
  currency_address: String!
  event: MongoID!
  rewards: [TicketTypeReward!]!
  photo_expanded: File
  vault_expanded: TokenRewardVault
}

type ClaimCheckinRewardSignatureResponse {
  settings: [CheckinTokenRewardSetting!]!
  signature: TokenRewardSignature
}

type TokenRewardSignature {
  claimId: String!
  signature: String!

  """
  The args that will be supplied to the contract
  """
  args: [JSON!]!
}

type ClaimTicketRewardSignatureResponse {
  settings: [TicketTokenRewardSetting!]!
  signature: TokenRewardSignature!
}

type EventPaymentStatistics {
  total_payments: Int!
  stripe_payments: PaymentStatistics!
  crypto_payments: CryptoPaymentStatistics!
}

type PaymentStatistics {
  count: Int!
  revenue: [PaymentRevenue!]!
}

type PaymentRevenue {
  currency: String!
  formatted_total_amount: String!
}

type CryptoPaymentStatistics {
  count: Int!
  revenue: [PaymentRevenue!]!
  networks: [CryptoPaymentNetworkStatistics!]!
}

type CryptoPaymentNetworkStatistics {
  chain_id: String!
  count: Int!
}

type ListEventPaymentsResponse {
  total: Int!
  records: [NewPayment!]!
}

type DonationRecommendation {
  currency: String!
  amount: [String!]!
}

type ListDonationsResponse {
  items: [Donation!]!
  total: Int!
}

type Donation {
  _id: MongoID!
  from_email: String
  from_user: MongoID
  from_wallet: String
  tx_hash: String
  vault: MongoID!
  currency: String!
  amount: String!
  category: DonationCategory!

  """
  Id of the target event or user that receives the donation
  """
  category_ref: String!
  created_at: DateTimeISO!
  ticket_type: MongoID
  ticket_type_expanded: EventTicketType
  user_info: DonationUserInfo
  vault_expanded: DonationVault
}

enum DonationCategory {
  EVENT
  USER
}

type DonationUserInfo {
  _id: MongoID
  name: String
  email: String
  image_avatar: String
}

type SpaceTokenGate {
  _id: MongoID!

  """
  Display name of the token
  """
  name: String!
  token_address: String!

  """
  Decimal places of this token, for display purpose only
  """
  decimals: Float!
  min_value: String
  max_value: String
  network: String!

  """
  ERC721 if true, else ERC20
  """
  is_nft: Boolean
  space: MongoID!
  roles: [SpaceRole!]
  passed: Boolean
}

type Mutation {
  createBadge(input: CreateBadgeInput!): Badge!
  updateBadge(input: UpdateBadgeInput!, _id: MongoID!): Badge!
  deleteBadge(_id: MongoID!): Boolean!
  createBadgeList(input: CreateBadgeListInput!): BadgeList!
  updateBadgeList(input: UpdateBadgeListInput!, _id: MongoID!): BadgeList!
  deleteBadgeList(_id: MongoID!): Boolean!
  createComment(input: CommentInput!): Comment!
  deleteComment(_id: MongoID!): Boolean!
  generateCubejsToken(events: [MongoID!], site: MongoID, user: MongoID): String!
  mailTicketPaymentReceipt(ticket: MongoID!): Boolean!
  mailEventTicket(
    event: MongoID!
    payment: MongoID
    emails: [String!]!
  ): Boolean!
  createEvent(input: EventInput!): Event!
  updateEvent(input: EventInput!, _id: MongoID!): Event!
  cancelEvent(_id: MongoID!): Event!
  acceptEventTerms(input: AcceptEventTermsInput!): Boolean!
  inviteEvent(input: InviteEventInput!): Event!
  responseInvitation(input: ResponseInvitationInput!): Boolean!
  submitEventApplicationQuestions(
    event: MongoID!
    questions: [QuestionInput!]!
  ): [EventApplicationQuestion!]!
  deleteEventApplicationQuestions(
    questions: [MongoID!]!
    event: MongoID!
  ): Boolean!
  submitEventApplicationAnswers(
    answers: [EventApplicationAnswerInput!]!
    event: MongoID!
    email: String
  ): Boolean!
  createEventBroadcast(
    input: CreateEventBroadcastInput!
    event: MongoID!
  ): Boolean!
  updateEventBroadcast(
    input: UpdateEventBroadcastInput!
    event: MongoID!
    _id: MongoID!
  ): Boolean!
  deleteEventBroadcast(event: MongoID!, _id: MongoID!): Boolean!
  updateEventCheckins(input: UpdateEventCheckinInput!): [EventCheckin!]!
  updateEventCheckin(input: UpdateEventCheckinInput!): EventCheckin!
    @deprecated(
      reason: "\nprefer using updateEventCheckins instead,\nthis mutation will be removed after this new checkin apis,\nafter making sure FE/mobile has no longer using this mutation anymore\n"
    )
  manageEventCohostRequests(input: ManageEventCohostRequestsInput!): Boolean!
  decideEventCohostRequest(input: DecideEventCohostRequestInput!): Boolean!
  syncEventAttestation(chain_id: String!, event: MongoID!): Boolean!
  sendEventEmailSettingTestEmails(
    input: SendEventEmailSettingTestEmailsInput!
  ): Boolean!
  createEventEmailSetting(input: CreateEventEmailSettingInput!): EmailSetting
  updateEventEmailSetting(input: UpdateEventEmailSettingInput!): EmailSetting!
  deleteEventEmailSetting(_id: MongoID!): Boolean!
  submitEventFeedback(input: SubmitEventFeedbackInput!): Boolean!
  cancelEventInvitations(input: CancelEventInvitationsInput!): Boolean!
  decideUserJoinRequests(
    input: DecideUserJoinRequestsInput!
  ): [DecidedJoinRequest!]!
  createEventQuestion(input: CreateEventQuestionsInput!): EventQuestion!
  deleteEventQuestion(_id: MongoID!): Boolean!
  toggleEventQuestionLike(_id: MongoID!): Boolean!
  cloneEvent(input: CloneEventInput!): [MongoID!]!
  updateEventRewardUse(input: UpdateEventRewardUseInput!): Boolean!
  acceptEvent(email: String, _id: MongoID!): EventRsvp!
  declineEvent(message: String, _id: MongoID!): EventRsvp!
  checkinUser(event: MongoID!, user: MongoID!): EventRsvp!
  createEventSessionReservation(input: EventSessionReservationInput!): Boolean!
  deleteEventSessionReservation(input: EventSessionReservationInput!): Boolean!
  createEventStory(input: EventStoryInput!): Boolean!
  deleteEventStory(input: EventStoryInput!): Boolean!
  reorderTicketTypeCategories(
    event: MongoID!
    categories: [ReorderTicketTypeCategoryInput!]!
  ): Boolean!
  createEventTicketCategory(
    input: CreateEventTicketCategoryInput!
  ): EventTicketCategory!
  deleteEventTicketCategory(categories: [MongoID!]!, event: MongoID!): Boolean!
  updateEventTicketCategory(input: UpdateTicketTypeCategoryInput!): Boolean!
  createEventTicketDiscounts(
    event: MongoID!
    inputs: [EventPaymentTicketDiscountInput!]!
  ): Event!
  deleteEventTicketDiscounts(event: MongoID!, discounts: [String!]!): Event!
  reorderTicketTypes(
    event: MongoID!
    types: [ReorderTicketTypeInput!]!
  ): Boolean!
  createEventTicketType(input: EventTicketTypeInput!): EventTicketType!
  updateEventTicketType(
    input: EventTicketTypeInput!
    _id: MongoID!
  ): EventTicketType!
  deleteEventTicketType(event: MongoID!, _id: MongoID!): Boolean!
  createEventFromEventbrite(
    input: CreateEventFromEventbriteInput!
    id: String!
  ): Event!
  createEventbriteWebhookForEvent(
    eventbrite_event: String!
    _id: MongoID!
  ): Boolean!
  createFarcasterAccountKey: CreateFarcasterAccountKeyResponse!
  revokeFarcasterAccountKey: Boolean!
  syncFarcasterConnectionStatus: SyncFarcasterConnectionStatusResponse!
  createEventCast(event: MongoID!): Boolean!
  createCast(
    parent_url: String
    parent_cast: ParentCastInput
    text: String!
    embeds: [String!]
    mentions: [Int!]
    mentionsPositions: [Int!]
  ): Boolean!
  createCastReaction(
    type: ReactionType!
    target_cast_id: ParentCastInput
    target_url: String
  ): Boolean!
  deleteCastReaction(
    type: ReactionType!
    target_cast_id: ParentCastInput
    target_url: String
  ): Boolean!
  createFile(input: FileInput, url: String!): File!
  updateFile(input: FileInput!, _id: MongoID!): File!
  toggleFileLike(_id: MongoID!): File!
  createFileUploads(
    upload_infos: [FileUploadInfo!]!
    directory: String!
  ): [FileWithPresignedUrl!]!
  confirmFileUploads(ids: [MongoID!]!): Boolean!
  flagUser(_id: MongoID!, reason: String!): Boolean!
  flagEvent(_id: MongoID!, reason: String!): Boolean!
  flagPost(_id: MongoID!, reason: String!): Boolean!
  createGuildRoom(input: GuildRoomInput!): GuildRoom!
  deleteGuildRoom(_id: MongoID!): Boolean!
  joinGuildRoom(_id: MongoID!): Boolean!
  generateMatrixToken: String!
  updatePayment(input: UpdatePaymentInput!): NewPayment!
  createNewPaymentAccount(
    input: CreateNewPaymentAccountInput!
  ): NewPaymentAccount!
  updateNewPaymentAccount(
    input: UpdateNewPaymentAccountInput!
  ): NewPaymentAccount!
  createPost(input: PostInput!): Post!
  deletePost(_id: MongoID!): Boolean!
  updatePost(input: UpdatePostInput!, _id: MongoID!): Post!
  toggleReaction(input: ReactionInput!): Boolean!
  deleteNotifications(
    _id: [MongoID!]
    type: NotificationTypeFilterInput
  ): Boolean!
  readNotifications(
    _id: [MongoID!]
    type: NotificationTypeFilterInput
  ): Boolean!
  revokeOauth2(name: String!): String!
  createOauth2Client(input: Oauth2ClientInput!): OAuth2Client!
  deleteOauth2Client(id: String!): Boolean!
  updateOauth2Client(input: Oauth2ClientInput!, id: String!): OAuth2Client!
  createRegistration(input: Registration!): Boolean!
  sendRoomInvite(input: SendRoomInviteInput!): Boolean!
  createRoom(input: RoomInput!): Room!
  updateRoom(input: RoomInput!, _id: MongoID!): Room!
  decideRoomAccessRequest(input: DecideRoomAccessRequestInput!): Boolean!
  modifyRoomStage(input: ModifyRoomStageInput!): ModifyRoomStagePayload!
  requestRoomStage(input: RequestRoomStageInput!): Boolean!
  decideRoomStageRequest(input: DecideRoomStageRequestInput!): Boolean!
  createStripeOnrampSession(
    input: CreateStripeOnrampSessionInput!
  ): StripeOnrampSession!
  createSite(input: CreateSiteInput!): Site!
  updateSite(input: UpdateSiteInput!, _id: MongoID!): Site
  deleteSite(_id: MongoID!): Boolean!
  createSpace(input: SpaceInput!): Space!
  activatePersonalSpace(input: SpaceInput!): ActivatePersonalSpace!
  updateSpace(input: SpaceInput!, _id: MongoID!): Space
  deleteSpace(_id: MongoID!): Boolean!
  pinEventsToSpace(
    tags: [MongoID!]
    events: [MongoID!]!
    space: MongoID!
  ): PinEventsToSpaceResponse!
  unpinEventsFromSpace(events: [MongoID!]!, space: MongoID!): Boolean!
  followSpace(space: MongoID!): Boolean!
  unfollowSpace(space: MongoID!): Boolean!
  addSpaceMembers(input: AddSpaceMemberInput!): Boolean!
  deleteSpaceMembers(input: DeleteSpaceMemberInput!): [SpaceMember!]!
  updateSpaceMember(input: UpdateSpaceMemberInput!): SpaceMember
  updateSpaceRoleFeatures(input: UpdateSpaceRoleFeaturesInput!): Boolean!
  createStore(input: StoreInput!): Store!
  updateStore(_id: MongoID!, input: StoreInput!): Store!
  deleteStore(_id: MongoID!): Boolean!
  createStoreBucketItem(input: StoreBucketItemInput!): StoreBucketItem!
  updateStoreBucketItem(
    input: UpdateStoreBucketItemInput!
    _id: MongoID!
  ): StoreBucketItem
  deleteStoreBucketItem(_id: MongoID!): Boolean!
  createStoreCategory(
    store: MongoID!
    input: StoreCategoryInput!
  ): StoreCategory!
  updateStoreCategory(
    _id: MongoID!
    store: MongoID!
    input: StoreCategoryInput!
  ): StoreCategory!
  deleteStoreCategory(_id: MongoID!, store: MongoID!): Boolean!
  createStoreOrder(
    store: MongoID!
    bucket_items: [StoreBucketItemInput!]
    address: MongoID!
    delivery_option: MongoID
    delivery_option_pickup_address: MongoID
    promotion: MongoID
    place_reservation: MongoID
    easyship_courier_id: String
    dry_run: Boolean
  ): StoreOrder!
  updateStoreOrder(input: StoreOrderInput!, _id: MongoID!): StoreOrder!
  createStoreProduct(store: MongoID!, input: StoreProductInput!): StoreProduct!
  updateStoreProduct(
    store: MongoID!
    _id: MongoID!
    input: StoreProductInput!
  ): StoreProduct!
  deleteStoreProduct(store: MongoID!, _id: MongoID!): Boolean!
  createStoreProductVariant(
    store: MongoID!
    product: MongoID!
    input: StoreProductVariantInput!
  ): StoreProductVariant!
  updateStoreProductVariant(
    store: MongoID!
    product: MongoID!
    input: StoreProductVariantInput!
    _id: MongoID!
  ): StoreProductVariant!
  deleteStoreProductVariant(
    store: MongoID!
    product: MongoID!
    _id: MongoID!
  ): Boolean!
  createStorePromotion(
    store: MongoID!
    input: StorePromotionInput!
  ): StorePromotion!
  deleteStorePromotion(_id: MongoID!, store: MongoID!): Boolean!
  createStripeCard(payment_method: String!): StripeCard!
  deleteStripeCard(_id: MongoID!): StripeCard!
  disconnectStripeAccount: Boolean!
  generateStripeAccountLink(
    refresh_url: String!
    return_url: String!
  ): GenerateStripeAccountLinkResponse!
  updateStripeConnectedAccountCapability(
    input: UpdateStripeConnectedAccountCapabilityInput!
  ): StripeAccountCapability!
  tgSendCode(input: SendCodeInput!): String!
  tgVerify(input: VerifyCodeInput!): Boolean!
  tgUnlinkAccount: Boolean!
  cancelTickets(input: CancelTicketsInput!): Boolean!
  assignTickets(input: AssignTicketsInput!): Boolean!
  redeemTickets(input: RedeemTicketsInput!): RedeemTicketsResponse!
  createTickets(
    ticket_type: MongoID!
    ticket_assignments: [TicketAssignment!]!
  ): [Ticket!]!
  buyTickets(input: BuyTicketsInput!): BuyTicketsResponse!
  revokeTwitter: String!
  deleteUser: Boolean!
  updateUser(input: UserInput!): User!
  addUserFcmToken(token: String!): Boolean!
  removeUserFcmToken(token: String!): Boolean!
  reportUser(input: ReportUserInput!): Boolean!
  toggleBlockUser(input: ToggleBlockUserInput!): Boolean!
  inviteUserContacts(_id: MongoID): Boolean!
  acceptUserDiscovery(
    swipee: MongoID!
    message: String
    event: MongoID
  ): AcceptUserDiscoveryResponse!
  declineUserDiscovery(
    swipee: MongoID!
    message: String
    event: MongoID
  ): Boolean!
  rewindUserDiscovery(event: MongoID): RewindUserDiscoveryResponse!
  deleteUserDiscoverySwipe(swipee: MongoID!): Boolean!
  createUserFollow(followee: MongoID!): Boolean!
  deleteUserFollow(followee: MongoID!): Boolean!
  createUserFriendship(input: CreateUserFriendshipInput!): UserFriendship!
  deleteUserFriendship(input: DeleteUserFriendshipInput!): Boolean!
  createUserService(title: String!): UserServiceOffer!
  createUserExpertise(title: String!): UserExpertise!
  setUserWallet(token: String!, signature: String!): Boolean!
  castVote(input: CastVoteInput!): Boolean!
  decideSpaceEventRequests(input: DecideSpaceEventRequestsInput!): Boolean!
  insertSpaceTag(input: SpaceTagInput!): SpaceTagBase!
  deleteSpaceTag(_id: MongoID!, space: MongoID!): Boolean!
  manageSpaceTag(
    tagged: Boolean!
    target: String!
    _id: MongoID!
    space: MongoID!
  ): Boolean!
  createRewardVault(input: TokenRewardVaultInput!): TokenRewardVault!
  updateRewardVault(
    input: TokenRewardVaultInput!
    _id: MongoID!
  ): TokenRewardVault
  createCheckinTokenRewardSetting(
    input: CheckinTokenRewardSettingInput!
  ): CheckinTokenRewardSetting!
  createTicketTokenRewardSetting(
    input: TicketTokenRewardSettingInput!
  ): TicketTokenRewardSetting!
  updateCheckinTokenRewardSetting(
    input: CheckinTokenRewardSettingInput!
    _id: MongoID!
  ): CheckinTokenRewardSetting!
  updateTicketTokenRewardSetting(
    input: TicketTokenRewardSettingInput!
    _id: MongoID!
  ): TicketTokenRewardSetting!
  createDonationVault(input: DonationVaultInput!): DonationVault!
  updateDonationVault(input: DonationVaultInput!, _id: MongoID!): DonationVault
  createDonation(input: CreateDonationInput!): Donation!
  updateDonation(input: UpdateDonationInput!): Boolean!
  createSpaceTokenGate(input: SpaceTokenGateInput!): SpaceTokenGate!
  deleteSpaceTokenGate(space: MongoID!, _id: MongoID!): Boolean!
  updateSpaceTokenGate(input: SpaceTokenGateInput!): SpaceTokenGate!
  syncSpaceTokenGateAccess(space: MongoID!): SyncSpaceTokenGateAccessResponse!
}

input CreateBadgeInput {
  network: String!
  contract: String!
  list: MongoID!
}

input UpdateBadgeInput {
  network: String
  contract: String
}

input CreateBadgeListInput {
  title: String!
  image_url: String
}

input UpdateBadgeListInput {
  title: String
  image_url: String
}

input CommentInput {
  text: String!
  post: MongoID!
  comment: MongoID
}

input EventInput {
  title: String
  start: DateTimeISO
  end: DateTimeISO
  visible_cohosts: [MongoID!]
  donation_enabled: Boolean
  donation_show_history: Boolean
  donation_vaults: [MongoID!]
  application_required: Boolean
  rsvp_wallet_platforms: [ApplicationBlokchainPlatformInput!]
  application_form_url: String
  application_profile_fields: [ApplicationProfileFieldInput!]
  accepted_store_promotion: MongoID
  accepted_user_fields_required: [String!]
  access_pass: AccessPassInput
  address: AddressInput
  address_directions: [String!]
  broadcast_rooms: [BroadcastRoomInput!]
  comments: String
  cost: Float
  currency: String
  cover: String
  cta_button_text: String

  """
  Show secondary CTA button text
  """
  cta_secondary_visible: Boolean
  description: String
  description_plain_text: String
  events: [MongoID!]
  frequent_questions: [FrequentQuestionInput!]
  guest_limit: Float
  guest_limit_per: Float
  hide_chat_action: Boolean
  hide_cohosts: Boolean
  hide_creators: Boolean
  hide_lounge: Boolean
  hide_invite_action: Boolean
  hide_question_box: Boolean
  hide_rooms_action: Boolean
  hide_session_guests: Boolean
  hide_speakers: Boolean
  hide_stories_action: Boolean
  hide_attending: Boolean
  latitude: Float
  layout_sections: [LayoutSectionInput!]
  longitude: Float
  new_photos: [FileInlineInput!]
  new_new_photos: [MongoID!]
  offers: [EventOfferInput!]
  payment_accounts_new: [MongoID!]
  payment_donation: Boolean
  payment_donation_amount_includes_tickets: Boolean
  payment_donation_message: String
  payment_donation_target: Float
  payment_optional: Boolean
  payment_ticket_purchase_title: String
  photos: [String!]
  private: Boolean
  published: Boolean
  registration_disabled: Boolean
  approval_required: Boolean
  rewards: [EventRewardInput!]
  sessions: [EventSessionInput!]
  speaker_emails: [String!]
  speaker_users: [MongoID!]
  stores: [MongoID!]
  stories: [MongoID!]
  space: MongoID
  listing_spaces: [MongoID!]
  tags: [String!]
  terms_email_permission_text: Boolean
  terms_text: String
  timezone: String
  virtual: Boolean
  virtual_url: String
  welcome_text: String
  welcome_video: VideoInput
  zones_menu_text: String
  checkin_menu_text: String
  guest_directory_enabled: Boolean
  subevent_enabled: Boolean
  subevent_settings: SubeventSettingsInput
  subevent_parent: MongoID
  telegram_channels: [TelegramChannelInput!]
}

input ApplicationBlokchainPlatformInput {
  platform: BlockchainPlatform!
  required: Boolean
}

input ApplicationProfileFieldInput {
  field: String!
  required: Boolean
}

input AccessPassInput {
  contract: String!
  network: String!
  frame: String!
  base: String!
  name: String!
  logo_url: String!
  info_url: String!
  card_image_url: String!
  card_logo_url: String!
  gallery_logo_url: String!
  card_description: String!
  dialog_background_url: String!
  dialog_title: String!
  dialog_description: String!
  metadata_name: String!
  metadata_description: String!
  metadata_creators: [String!]!
  unlocked_description: String
  twitter_url: String
  instagram_url: String
  discord_url: String
  checkin: Boolean
}

input BroadcastRoomInput {
  _id: MongoID
  title: String
  description: String
  photos: [MongoID!]
  event_payment_ticket_types: [MongoID!]
  position: Float
  iframe_src: String
}

input FileInlineInput {
  id: MongoID!
  url: String!
  key: String!
  fa_file: MongoID
  fa_index: Float
}

input EventOfferInput {
  _id: MongoID
  provider: OfferProvider!
  provider_network: String!
  provider_id: String!
  position: Float
  auto: Boolean
  broadcast_rooms: [MongoID!]
}

input EventRewardInput {
  _id: MongoID
  active: Boolean!
  title: String!
  limit: Float
  limit_per: Float!
  icon_color: String
  icon_url: String
  payment_ticket_types: [MongoID!]
}

input EventSessionInput {
  _id: MongoID
  title: String!
  start: DateTimeISO!
  end: DateTimeISO!
  broadcast: MongoID
  description: String
  photos: [MongoID!]
  speaker_users: [MongoID!]
  votings: [MongoID!]
}

input VideoInput {
  provider: String!
  provider_id: String!
  title: String
  thumbnail: String
}

input SubeventSettingsInput {
  ticket_required_for_creation: Boolean
  ticket_required_for_purchase: Boolean
}

input TelegramChannelInput {
  id: String
  accessHash: String
  photo: MongoID
  title: String
  username: String
  inviteLink: String
  joined: [MongoID!]
}

input AcceptEventTermsInput {
  _id: MongoID!
  email_permission: Boolean
}

input InviteEventInput {
  _id: MongoID!
  users: [MongoID!]
  phones: [String!]
  emails: [String!]
}

input ResponseInvitationInput {
  _id: MongoID!
  action: InvitationState!
}

enum InvitationState {
  DECLINED
}

input QuestionInput {
  _id: MongoID
  question: String
  required: Boolean
  position: Int
  type: QuestionType!
  options: [String!]
  select_type: SelectType
  questions: [String!]
}

input EventApplicationAnswerInput {
  question: MongoID!
  answer: String
  answers: [String!]
}

input CreateEventBroadcastInput {
  provider: BroadcastProvider!
  provider_id: String!
  title: String!
  description: String
  position: Float
  rooms: [MongoID!]
  thumbnail: String
  scheduled_start_time: DateTimeISO
  scheduled_end_time: DateTimeISO
}

input UpdateEventBroadcastInput {
  description: String
  position: Float
  rooms: [MongoID!]
  thumbnail: String
}

input UpdateEventCheckinInput {
  active: Boolean!
  shortids: [String!]
  shortid: String
    @deprecated(
      reason: "Prefer using `shortids` along with `updateEventCheckins` mutation instead"
    )
  event: MongoID @deprecated(reason: "use shortIds instead")
  user: MongoID @deprecated(reason: "use shortIds instead")
}

input ManageEventCohostRequestsInput {
  event: MongoID!
  decision: Boolean!
  users: [MongoID!]
  emails: [String!]
}

input DecideEventCohostRequestInput {
  event: MongoID!
  decision: Boolean!
}

input SendEventEmailSettingTestEmailsInput {
  custom_subject_html: String
  custom_body_html: String
  recipient_filters: EmailRecipientFiltersInput
  event: MongoID
  type: EmailTemplateType
  _id: MongoID
  test_recipients: [String!]!
}

input EmailRecipientFiltersInput {
  ticket_types: [MongoID!]
  join_request_states: [EventJoinRequestState!]
}

input CreateEventEmailSettingInput {
  custom_subject_html: String
  custom_body_html: String
  cc: [String!]
  disabled: Boolean
  scheduled_at: DateTimeISO
  recipient_types: [EmailRecipientType!]
  recipient_filters: EmailRecipientFiltersInput
  event: MongoID!
  type: EmailTemplateType!
}

input UpdateEventEmailSettingInput {
  custom_subject_html: String
  custom_body_html: String
  cc: [String!]
  disabled: Boolean
  scheduled_at: DateTimeISO
  recipient_types: [EmailRecipientType!]
  recipient_filters: EmailRecipientFiltersInput
  _id: MongoID!
}

input SubmitEventFeedbackInput {
  rate_value: Float!
  comment: String
  token: String!
}

input CancelEventInvitationsInput {
  invitations: [MongoID!]!
  event: MongoID!
}

type DecidedJoinRequest {
  _id: MongoID!
  processed: Boolean!
}

input DecideUserJoinRequestsInput {
  event: MongoID!
  requests: [MongoID!]!
  decision: EventJoinRequestState!
}

input CreateEventQuestionsInput {
  event: MongoID!
  question: String!
  session: MongoID
}

input CloneEventInput {
  event: MongoID!
  dates: [DateTimeISO!]!
  overrides: EventInput
}

input UpdateEventRewardUseInput {
  event: MongoID!
  reward_id: MongoID!
  reward_number: Float!
  user: MongoID!
  active: Boolean!
}

type EventRsvp {
  state: EventRsvpState!
  messages: EventRsvpMessages
  payment: EventRsvpPayment
}

enum EventRsvpState {
  pending
  payment
  accepted
  declined
}

type EventRsvpMessages {
  primary: String!
  secondary: String
}

type EventRsvpPayment {
  amount: Float!
  currency: String!
  provider: String!
}

input EventSessionReservationInput {
  event: MongoID!
  session: MongoID!
}

input EventStoryInput {
  event: MongoID!
  file: MongoID!
}

input ReorderTicketTypeCategoryInput {
  _id: MongoID!
  position: Int
}

input CreateEventTicketCategoryInput {
  title: String!
  event: MongoID!
  description: String
  position: Int
  ticket_types: [MongoID!]
}

input UpdateTicketTypeCategoryInput {
  _id: MongoID!
  title: String!
  event: MongoID!
  description: String
  position: Int
  ticket_types: [MongoID!]
}

input EventPaymentTicketDiscountInput {
  code: String!
  ratio: Float!
  use_limit: Float
  use_limit_per: Float
  ticket_limit: Float
  ticket_limit_per: Float
  ticket_types: [MongoID!]
}

input ReorderTicketTypeInput {
  _id: MongoID!
  position: Int
}

input EventTicketTypeInput {
  active: Boolean
  private: Boolean
  limited: Boolean
  limited_whitelist_ids: [MongoID!]
  limited_whitelist_emails: [String!]
  event: MongoID
  title: String
  prices: [EventTicketPriceInput!]
  category: MongoID
  default: Boolean
  address_required: Boolean
  description: String
  description_line: String
  external_ids: [String!]
  photos: [MongoID!]
  ticket_limit: Float
  ticket_limit_per: Float
  position: Int
  approval_required: Boolean
  offers: [EventTicketTypeOffersInput!]
  added_whitelist_emails: [String!]
  removed_whitelist_emails: [String!]
}

input EventTicketPriceInput {
  default: Boolean
  currency: String!
  cost: String!
  payment_accounts: [MongoID!]
}

input EventTicketTypeOffersInput {
  _id: MongoID
  provider: OfferProvider
  provider_network: String
  provider_id: String
  position: Float
  auto: Boolean
  broadcast_rooms: [MongoID!]
}

input CreateEventFromEventbriteInput {
  title: String
  description: String
  start: DateTimeISO
  end: DateTimeISO
}

type CreateFarcasterAccountKeyResponse {
  account_key_request: AccountKeyRequest!
}

type SyncFarcasterConnectionStatusResponse {
  userFid: Float!
  accepted: Boolean!
}

input ParentCastInput {
  fid: Float!

  """
  Hash of the parent cast without 0x prefix
  """
  hash: String!
}

enum ReactionType {
  NONE
  LIKE
  RECAST
}

input FileInput {
  description: String
}

type FileWithPresignedUrl {
  _id: MongoID
  stamp: DateTimeISO!
  state: FileState!
  owner: MongoID!
  type: String!
  size: Float
  url: String!
  bucket: String!
  key: String!
  links: [FileLink!]
  likes: Float!
  likers: [MongoID!]
  description: String
  owner_expanded: User
  liked: Boolean
  link_events_expanded(skip: Int! = 0, limit: Int! = 25): [Event]
  link_stores_expanded(skip: Int! = 0, limit: Int! = 25): [Store]
  link_store_products_expanded(skip: Int! = 0, limit: Int! = 25): [StoreProduct]
  link_users_expanded(skip: Int! = 0, limit: Int! = 25): [User]
  presigned_url: String!
}

input FileUploadInfo {
  description: String
  extension: String!
}

input GuildRoomInput {
  title: String!
  guild_id: Float!
  guild_role_ids: [Int!]
  guild_role_require_all: Boolean
  matrix_room_id: String!
}

input UpdatePaymentInput {
  _id: MongoID!
  transfer_params: JSON
  payment_secret: String
}

input CreateNewPaymentAccountInput {
  type: PaymentAccountType!
  title: String
  provider: NewPaymentProvider
  account_info: JSON
}

input UpdateNewPaymentAccountInput {
  _id: MongoID!
  title: String
  account_info: JSON!
}

input PostInput {
  visibility: PostVisibility!
  text: String
  ref_type: PostRefType
  ref_id: String
}

input UpdatePostInput {
  visibility: PostVisibility
  published: Boolean
}

input ReactionInput {
  active: Boolean!
  post: MongoID!
}

input Oauth2ClientInput {
  client_name: String
  skip_consent: Boolean
  logo_uri: String
  redirect_uris: [String!]
  allowed_cors_origins: [String!]
  metadata: JSON
  post_logout_redirect_uris: [String!]
  authorization_code_grant_access_token_lifespan: String
  authorization_code_grant_id_token_lifespan: String
  authorization_code_grant_refresh_token_lifespan: String
  client_credentials_grant_access_token_lifespan: String
  implicit_grant_access_token_lifespan: String
  implicit_grant_id_token_lifespan: String
  jwt_bearer_grant_access_token_lifespan: String
  refresh_token_grant_id_token_lifespan: String
  refresh_token_grant_access_token_lifespan: String
  refresh_token_grant_refresh_token_lifespan: String
}

input Registration {
  client: String!
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  country: String
  postal_code: String
  consent_communications: Boolean
}

input SendRoomInviteInput {
  _id: MongoID!
  users: [MongoID!]!
}

input RoomInput {
  active: Boolean
  title: String
  state: RoomState
  start: DateTimeISO
  cohosts: [MongoID!]
  access_users: [MongoID!]
  private: Boolean
  verify: Boolean
  description: String
  event: MongoID
  payment_direct: Boolean
  photos: [MongoID!]
  stage_open: Boolean
  theme_background_photo: MongoID
  theme_color: String
  theme_layout: Float
  video: VideoInput
  highlight_stores: [MongoID!]
  highlight_events: [MongoID!]
  highlight_rooms: [MongoID!]
  highlight_users: [MongoID!]
  offers: [RoomOfferInput!]
}

input RoomOfferInput {
  _id: MongoID
  provider: OfferProvider
  provider_network: String
  provider_id: String
  position: Float
}

input DecideRoomAccessRequestInput {
  _id: MongoID!
  user: MongoID!
  decision: Boolean!
}

type ModifyRoomStagePayload {
  credentials: RoomCredentials
}

input ModifyRoomStageInput {
  _id: MongoID!
  user: MongoID!
  staged: Boolean!
}

input RequestRoomStageInput {
  _id: MongoID!
  user: MongoID!
}

input DecideRoomStageRequestInput {
  _id: MongoID!
  user: MongoID!
  decision: Boolean!
}

type StripeOnrampSession {
  publishable_key: String!
  client_secret: String!
}

input CreateStripeOnrampSessionInput {
  wallet_address: String
  source_currency: String
  destination_currency: String
  destination_network: String
  destination_amount: Float
}

input CreateSiteInput {
  client: String!
  hostnames: [String!]
  title: String!
  description: String!
  access_pass: AccessPassInput
  header_metas: [SiteHeaderMetaInput!]
  header_links: [SiteHeaderLinkInput!]
  footer_scripts: [SiteFooterScriptInput!]
  ai_config: MongoID
  event: MongoID
  onboarding_steps: [SiteOnboardingStepInput!]
  owners: [MongoID!]
  partners: [MongoID!]
  share_url: JSON
  favicon_url: String
  logo_url: String
  logo_mobile_url: String
  passports: [SitePassportInput!]
  privacy_url: String
  theme_data: JSON
  theme_type: String
  text: JSON
  visibility: JSON
}

input SiteHeaderMetaInput {
  key: String
  name: String
  property: String
  content: String
}

input SiteHeaderLinkInput {
  rel: SiteHeaderLinkRel
  href: String
}

input SiteFooterScriptInput {
  strategy: SiteFooterScriptStrategy
  src: String
  id: String
  children: String
}

input SiteOnboardingStepInput {
  name: SiteOnboardingStepName!
  data: JSON
}

input SitePassportInput {
  name: String!
  image: String!
  logo: String!
  baseV1Address: String!
  baseV1ChainId: Float!
  passportV1CallAddress: String!
  ssiGroup: String!
  passportV1AxelarAddress: JSON
  crowdfundAddress: JSON
}

input UpdateSiteInput {
  client: String
  hostnames: [String!]
  title: String
  description: String
  access_pass: AccessPassInput
  header_metas: [SiteHeaderMetaInput!]
  header_links: [SiteHeaderLinkInput!]
  footer_scripts: [SiteFooterScriptInput!]
  ai_config: MongoID
  event: MongoID
  onboarding_steps: [SiteOnboardingStepInput!]
  owners: [MongoID!]
  partners: [MongoID!]
  share_url: JSON
  favicon_url: String
  logo_url: String
  logo_mobile_url: String
  passports: [SitePassportInput!]
  privacy_url: String
  theme_data: JSON
  theme_type: String
  text: JSON
  visibility: JSON
  active: Boolean
}

input SpaceInput {
  title: String
  description: String

  """
  Private space requires moderation for membership
  """
  private: Boolean
  state: SpaceState
  tint_color: String
  slug: String
  handle_twitter: String
  handle_instagram: String
  handle_youtube: String
  handle_tiktok: String
  handle_linkedin: String
  website: String
  address: AddressInput
  image_avatar: MongoID
  image_cover: MongoID
  theme_data: JSON
  hostnames: [String!]
}

type ActivatePersonalSpace {
  space: Space!
  personal_space: Space!
}

type PinEventsToSpaceResponse {
  requests: [SpaceEventRequest!]
}

input AddSpaceMemberInput {
  space: MongoID!
  role: SpaceRole!
  visible: Boolean
  users: [AddMemberInput!]!
  tags: [MongoID!]
}

input AddMemberInput {
  email: String!
  user_name: String
}

input DeleteSpaceMemberInput {
  space: MongoID!
  ids: [MongoID!]!
}

input UpdateSpaceMemberInput {
  _id: MongoID
  role: SpaceRole
  visible: Boolean
}

input UpdateSpaceRoleFeaturesInput {
  space: MongoID!
  role: String!
  codes: [FeatureCode!]!
}

input StoreInput {
  _id: MongoID
  managers: [MongoID!]
  title: String
  currency: String
  api_secret: String
  easyship_enabled: Boolean
  easyship_company_id: String
  easyship_token: String
  easyship_secret_key: String
  delivery_options: [DeliveryOptionInput!]
  sales_taxes: [SalesTaxInput!]
  photos: [FileInlineInput!]
  new_photos: [MongoID!]
  tags: [String!]
  age_restriction_min: Float
  age_restriction_reason: String
}

input DeliveryOptionInput {
  _id: MongoID!
  type: DeliveryOptionType!
  title: String!
  cost: Float!
  fulfillment_address: MongoID
  pickup_addresses: [MongoID!]
  waive_type: DeliveryOptionWaiveType
  waive_value_threshold: Float
  group: String
  description: String
  longitude: Float
  latitude: Float
  search_range: Float
  polygon: JSON
  countries: [String!]
  regions: [String!]
  cities: [String!]
  postals: [String!]
  postal_ranges: [DeliveryOptionPostalRangeInput!]
}

input DeliveryOptionPostalRangeInput {
  _id: MongoID!
  pattern: String!
  min: Float!
  max: Float!
}

input SalesTaxInput {
  _id: MongoID!
  type: SalesTaxType!
  name: String
  flat_map: JSON
  ratio_map: JSON
  countries: [String!]
  regions: [String!]
}

input StoreBucketItemInput {
  product: MongoID!
  product_variant: MongoID!
  product_groups: JSON!
  count: Float!
}

input UpdateStoreBucketItemInput {
  count: Float!
}

input StoreCategoryInput {
  title: String
  description: String
  parents: [MongoID!]
}

input StoreOrderInput {
  state: StoreOrderState!
  items: [StoreOrderItemInput!]!
}

input StoreOrderItemInput {
  _id: MongoID!
  state: StoreOrderItemState!
  amount: Float!
  delivery_option: DeliveryOptionInput
  delivery_cost: Float
  delivery_option_cost_waived: Boolean
  inventory: Float
  tax: Float
  tracking_url: String
}

input StoreProductInput {
  _id: MongoID
  order: Float
  title: String
  description: String
  categories: [MongoID!]
  delivery_options: [DeliveryOptionInput!]
  easyship_category: EasyshipCategory
  sales_tax_tag: String
  highlight: Boolean
  primary_group: String
}

input StoreProductVariantInput {
  _id: MongoID
  title: String
  cost: Float
  groups: JSON
  weight: Float
  length: Float
  width: Float
  height: Float
  photos: [FileInlineInput!]
  new_photos: [MongoID!]
  inventory: Float
}

input StorePromotionInput {
  type: StorePromotionType
  title: String
  ratio: Float
  use_limit: Float
  use_limit_per: Float
  event: MongoID
  products: [MongoID!]
}

type GenerateStripeAccountLinkResponse {
  url: String!
}

input UpdateStripeConnectedAccountCapabilityInput {
  id: String!
  capabilities: [CapabilityInput!]!
}

input CapabilityInput {
  type: StripeCapabilityType!
  preference: StripeAccountCapabilityDisplayPreferencePreference!
}

input SendCodeInput {
  phone_number: String!
}

input VerifyCodeInput {
  phone_number: String!
  phone_code_hash: String!
  phone_code: String!
  password_2fa: String
}

input CancelTicketsInput {
  event: MongoID!
  tickets: [MongoID!]!
}

input AssignTicketsInput {
  event: MongoID!
  assignees: [TicketAssignee!]!
}

input TicketAssignee {
  user: MongoID
  email: String
  ticket: MongoID!
}

type RedeemTicketsResponse {
  tickets: [Ticket!]
  join_request: EventJoinRequest
}

input RedeemTicketsInput {
  buyer_info: BuyerInfoInput
  connect_wallets: [ConnectWalletInput!]
  event: MongoID!
  items: [PurchasableItem!]!
  inviter: MongoID
  user_info: UserInput
}

input TicketAssignment {
  email: String!
  count: Float!
}

type BuyTicketsResponse {
  payment: NewPayment!
  join_request: EventJoinRequest
}

input BuyTicketsInput {
  buyer_info: BuyerInfoInput
  connect_wallets: [ConnectWalletInput!]
  event: MongoID!
  items: [PurchasableItem!]!
  inviter: MongoID
  user_info: UserInput
  currency: String!
  discount: String
  total: String!
  fee: String
  account_id: MongoID!
  billing_info: BillingInfoInput
  transfer_params: JSON
}

input BillingInfoInput {
  _id: MongoID
  recipient_name: String
  street_1: String
  street_2: String
  city: String
  region: String
  postal: String
  country: String
  title: String
  phone: String
  longitude: Float
  latitude: Float
  additional_directions: String
  email: String
  firstname: String
  lastname: String
}

input ReportUserInput {
  user: MongoID!
  reason: String
  block: Boolean
}

input ToggleBlockUserInput {
  user: MongoID!
  block: Boolean!
}

type AcceptUserDiscoveryResponse {
  state: UserDiscoverySwipeState
  user: User
}

type RewindUserDiscoveryResponse {
  decision: UserDiscoverySwipeDecision!
  user: User
}

input CreateUserFriendshipInput {
  user: MongoID!
  type: UserFriendshipType
}

input DeleteUserFriendshipInput {
  user: MongoID!
}

input CastVoteInput {
  voting_id: MongoID!
  option_id: String
}

input DecideSpaceEventRequestsInput {
  space: MongoID!
  requests: [MongoID!]!
  decision: SpaceEventRequestState!
}

input SpaceTagInput {
  space: MongoID!
  tag: String!
  color: String!
  type: SpaceTagType!
  _id: MongoID
}

input TokenRewardVaultInput {
  title: String
  network: String
  address: String
  tokens: [RewardTokenInput!]
}

input RewardTokenInput {
  address: String!
  symbol: String!
  name: String
  decimals: Int!
  icon: MongoID
  icon_url: String
}

input CheckinTokenRewardSettingInput {
  title: String
  photo: MongoID
  vault: MongoID
  currency_address: String
  event: MongoID
  rewards: [TicketTypeRewardInput!]
}

input TicketTypeRewardInput {
  ticket_type: MongoID!
  reward_per_ticket: String!
}

input TicketTokenRewardSettingInput {
  title: String
  photo: MongoID
  vault: MongoID
  currency_address: String
  event: MongoID
  rewards: [TicketTypeRewardInput!]
}

input DonationVaultInput {
  title: String
  network: String
  address: String
}

input CreateDonationInput {
  from_email: String
  vault: MongoID!
  currency: String!
  amount: String!
  category: DonationCategory!

  """
  Id of the target event or user that receives the donation
  """
  category_ref: String!
}

input UpdateDonationInput {
  _id: MongoID!
  from_wallet: String
  tx_hash: String
}

input SpaceTokenGateInput {
  _id: MongoID

  """
  Display name of the token
  """
  name: String
  token_address: String

  """
  Decimal places of this token, for display purpose only
  """
  decimals: Float
  min_value: String
  max_value: String
  network: String

  """
  ERC721 if true, else ERC20
  """
  is_nft: Boolean
  space: MongoID
  roles: [SpaceRole!]
}

type SyncSpaceTokenGateAccessResponse {
  roles: [SpaceRole!]!
}

type Subscription {
  postCreated: Post!
  notificationCreated: Notification!
  roomStarted(event: MongoID): Room!
  roomUpdated(_id: MongoID!): Room!
  roomAccess(_id: MongoID!): Boolean!
  roomAction(_id: MongoID!): RoomActionPayload!
  votingUpdated(_id: MongoID!): MongoID!
}

union RoomActionPayload =
    RoomActionPayload_Notify
  | RoomActionPayload_Renew
  | RoomActionPayload_AccessRequested
  | RoomActionPayload_AccessRequestDecided
  | RoomActionPayload_StageInvited
  | RoomActionPayload_StageModified
  | RoomActionPayload_StageRequestDecided
  | RoomActionPayload_StageRequested
  | RoomActionPayload_AttendingUsersModified

type RoomActionPayload_Notify {
  message: String!
}

type RoomActionPayload_Renew {
  credentials: RoomCredentials!
}

type RoomActionPayload_AccessRequested {
  user: MongoID!
  user_expanded: RoomUser!
  message: String!
}

type RoomUser {
  _id: MongoID!
  name: String
  image_avatar: String
  username: String
}

type RoomActionPayload_AccessRequestDecided {
  user: MongoID!
}

type RoomActionPayload_StageInvited {
  user: MongoID!
  user_expanded: RoomUser!
  message: String!
  requested: Boolean
}

type RoomActionPayload_StageModified {
  uid: Float!
  user: MongoID!
  staged: Boolean!
}

type RoomActionPayload_StageRequestDecided {
  user: MongoID!
}

type RoomActionPayload_StageRequested {
  user: MongoID!
  user_expanded: RoomUser!
  message: String!
}

type RoomActionPayload_AttendingUsersModified {
  user: MongoID!
  user_expanded: RoomUser!
  attending: Boolean!
}
